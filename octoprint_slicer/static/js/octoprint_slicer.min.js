(function (THREE$1) {
'use strict';

THREE$1 = 'default' in THREE$1 ? THREE$1['default'] : THREE$1;

/**
 * @author arodic / https://github.com/arodic
 */

function DefaultHandles() {

    var GizmoMaterial = function GizmoMaterial(parameters) {

        THREE$1.MeshBasicMaterial.call(this);

        this.depthTest = false;
        this.depthWrite = false;
        this.side = THREE$1.FrontSide;
        this.transparent = true;

        this.setValues(parameters);

        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;

        this.highlight = function (highlighted) {

            if (highlighted) {

                this.color.setRGB(1, 1, 0);
                this.opacity = 1;
            } else {

                this.color.copy(this.oldColor);
                this.opacity = this.oldOpacity;
            }
        };
    };

    GizmoMaterial.prototype = Object.create(THREE$1.MeshBasicMaterial.prototype);
    GizmoMaterial.prototype.constructor = GizmoMaterial;

    var GizmoLineMaterial = function GizmoLineMaterial(parameters) {

        THREE$1.LineBasicMaterial.call(this);

        this.depthTest = false;
        this.depthWrite = false;
        this.transparent = true;
        this.linewidth = 1;

        this.setValues(parameters);

        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;

        this.highlight = function (highlighted) {

            if (highlighted) {

                this.color.setRGB(1, 1, 0);
                this.opacity = 1;
            } else {

                this.color.copy(this.oldColor);
                this.opacity = this.oldOpacity;
            }
        };
    };

    GizmoLineMaterial.prototype = Object.create(THREE$1.LineBasicMaterial.prototype);
    GizmoLineMaterial.prototype.constructor = GizmoLineMaterial;

    var invisibleMaterial = new GizmoMaterial({ visible: false, transparent: false });

    var gizmoFromMap = function gizmoFromMap(gizmoMap) {

        var gizmo = new THREE$1.Object3D();

        for (var name in gizmoMap) {

            for (var i = gizmoMap[name].length; i--;) {

                var object = gizmoMap[name][i][0];
                var position = gizmoMap[name][i][1];
                var rotation = gizmoMap[name][i][2];

                object.name = name;

                if (position) object.position.set(position[0], position[1], position[2]);
                if (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);

                gizmo.add(object);
            }
        }

        return gizmo;
    };

    this.translateHandles = function () {
        var arrowGeometry = new THREE$1.Geometry();
        var mesh = new THREE$1.Mesh(new THREE$1.CylinderGeometry(0, 0.05, 0.2, 12, 1, false));
        mesh.position.y = 0.5;
        mesh.updateMatrix();

        arrowGeometry.merge(mesh.geometry, mesh.matrix);

        var lineXGeometry = new THREE$1.BufferGeometry();
        lineXGeometry.addAttribute('position', new THREE$1.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));

        var lineYGeometry = new THREE$1.BufferGeometry();
        lineYGeometry.addAttribute('position', new THREE$1.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

        var lineZGeometry = new THREE$1.BufferGeometry();
        lineZGeometry.addAttribute('position', new THREE$1.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

        return gizmoFromMap({
            X: [[new THREE$1.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE$1.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))], [new THREE$1.Mesh(new THREE$1.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

            Y: [[new THREE$1.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new THREE$1.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))], [new THREE$1.Mesh(new THREE$1.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0, 0.6, 0]]],

            Z: [[new THREE$1.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new THREE$1.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))], [new THREE$1.Mesh(new THREE$1.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

            XYZ: [[new THREE$1.Mesh(new THREE$1.OctahedronGeometry(0.1, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })), [0, 0, 0], [0, 0, 0]], [new THREE$1.Mesh(new THREE$1.OctahedronGeometry(0.2, 0), invisibleMaterial)]],

            XY: [[new THREE$1.Mesh(new THREE$1.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.15, 0.15, 0]], [new THREE$1.Mesh(new THREE$1.PlaneBufferGeometry(0.4, 0.4), invisibleMaterial), [0.2, 0.2, 0]]],

            YZ: [[new THREE$1.Mesh(new THREE$1.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.15, 0.15], [0, Math.PI / 2, 0]], [new THREE$1.Mesh(new THREE$1.PlaneBufferGeometry(0.4, 0.4), invisibleMaterial), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],

            XZ: [[new THREE$1.Mesh(new THREE$1.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]], [new THREE$1.Mesh(new THREE$1.PlaneBufferGeometry(0.4, 0.4), invisibleMaterial), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]

        });
    };

    this.rotateHandles = function () {

        var CircleGeometry = function CircleGeometry(radius, facing, arc) {

            var geometry = new THREE$1.BufferGeometry();
            var vertices = [];
            arc = arc ? arc : 1;

            for (var i = 0; i <= 64 * arc; ++i) {

                if (facing === 'x') vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);
                if (facing === 'y') vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0, Math.sin(i / 32 * Math.PI) * radius);
                if (facing === 'z') vertices.push(Math.sin(i / 32 * Math.PI) * radius, Math.cos(i / 32 * Math.PI) * radius, 0);
            }

            geometry.addAttribute('position', new THREE$1.Float32BufferAttribute(vertices, 3));
            return geometry;
        };

        return gizmoFromMap({
            X: [[new THREE$1.Line(new CircleGeometry(1, 'x', 0.5), new GizmoLineMaterial({ color: 0xff0000 }))], [new THREE$1.Mesh(new THREE$1.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), invisibleMaterial), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],

            Y: [[new THREE$1.Line(new CircleGeometry(1, 'y', 0.5), new GizmoLineMaterial({ color: 0x00ff00 }))], [new THREE$1.Mesh(new THREE$1.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), invisibleMaterial), [0, 0, 0], [Math.PI / 2, 0, 0]]],

            Z: [[new THREE$1.Line(new CircleGeometry(1, 'z', 0.5), new GizmoLineMaterial({ color: 0x0000ff }))], [new THREE$1.Mesh(new THREE$1.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), invisibleMaterial), [0, 0, 0], [0, 0, -Math.PI / 2]]],

            E: [[new THREE$1.Line(new CircleGeometry(1.25, 'z', 1), new GizmoLineMaterial({ color: 0xcccc00 }))], [new THREE$1.Mesh(new THREE$1.TorusBufferGeometry(1.25, 0.12, 2, 24), invisibleMaterial)]],

            XYZE: [[new THREE$1.Line(new CircleGeometry(1, 'z', 1), new GizmoLineMaterial({ color: 0x787878 }))], [new THREE$1.Mesh()] // TODO
            ]
        });
    };

    this.scaleHandles = function () {
        var arrowGeometry = new THREE$1.Geometry();
        var mesh = new THREE$1.Mesh(new THREE$1.BoxGeometry(0.125, 0.125, 0.125));
        mesh.position.y = 0.5;
        mesh.updateMatrix();

        arrowGeometry.merge(mesh.geometry, mesh.matrix);

        var lineXGeometry = new THREE$1.BufferGeometry();
        lineXGeometry.addAttribute('position', new THREE$1.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));

        var lineYGeometry = new THREE$1.BufferGeometry();
        lineYGeometry.addAttribute('position', new THREE$1.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

        var lineZGeometry = new THREE$1.BufferGeometry();
        lineZGeometry.addAttribute('position', new THREE$1.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

        return gizmoFromMap({
            X: [[new THREE$1.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE$1.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))], [new THREE$1.Mesh(new THREE$1.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

            Y: [[new THREE$1.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new THREE$1.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))], [new THREE$1.Mesh(new THREE$1.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0, 0.6, 0]]],

            Z: [[new THREE$1.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new THREE$1.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))], [new THREE$1.Mesh(new THREE$1.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

            XYZ: [[new THREE$1.Mesh(new THREE$1.BoxBufferGeometry(0.125, 0.125, 0.125), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))], [new THREE$1.Mesh(new THREE$1.BoxBufferGeometry(0.4, 0.4, 0.4), invisibleMaterial)]]
        });
    };
}

function TransformGizmo(handles) {

    this.handles = handles;

    this.init = function () {

        THREE$1.Object3D.call(this);

        this.add(this.handles);

        this.planes = new THREE$1.Object3D();
        this.add(this.planes);

        //// PLANES

        var planeGeometry = new THREE$1.PlaneBufferGeometry(50, 50, 2, 2);
        var planeMaterial = new THREE$1.MeshBasicMaterial({ visible: false, side: THREE$1.DoubleSide });

        var planes = {
            "XY": new THREE$1.Mesh(planeGeometry, planeMaterial),
            "YZ": new THREE$1.Mesh(planeGeometry, planeMaterial),
            "XZ": new THREE$1.Mesh(planeGeometry, planeMaterial),
            "XYZE": new THREE$1.Mesh(planeGeometry, planeMaterial)
        };

        this.activePlane = planes["XYZE"];

        planes["YZ"].rotation.set(0, Math.PI / 2, 0);
        planes["XZ"].rotation.set(-Math.PI / 2, 0, 0);

        for (var i in planes) {

            planes[i].name = i;
            this.planes.add(planes[i]);
            this.planes[i] = planes[i];
        }

        // reset Transformations

        this.traverse(function (child) {

            if (child instanceof THREE$1.Mesh) {

                child.updateMatrix();

                var tempGeometry = child.geometry.clone();
                tempGeometry.applyMatrix(child.matrix);
                child.geometry = tempGeometry;

                child.position.set(0, 0, 0);
                child.rotation.set(0, 0, 0);
                child.scale.set(1, 1, 1);
            }
        });
    };

    this.setHandles = function (handles) {

        this.remove(this.handles);
        this.handles = handles;
        if (this.handles !== null) {
            this.add(this.handles);
        }
    };

    this.highlight = function (axis) {

        this.traverse(function (child) {

            if (child.material && child.material.highlight) {

                if (child.name === axis) {

                    child.material.highlight(true);
                } else {

                    child.material.highlight(false);
                }
            }
        });
    };
}

TransformGizmo.prototype = Object.create(THREE$1.Object3D.prototype);
TransformGizmo.prototype.constructor = THREE$1.TransformGizmo;

TransformGizmo.prototype.update = function (rotation, eye) {

    var vec1 = new THREE$1.Vector3(0, 0, 0);
    var vec2 = new THREE$1.Vector3(0, 1, 0);
    var lookAtMatrix = new THREE$1.Matrix4();

    this.traverse(function (child) {

        if (child.name.search("E") !== -1) {

            child.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));
        } else if (child.name.search("X") !== -1 || child.name.search("Y") !== -1 || child.name.search("Z") !== -1) {

            child.quaternion.setFromEuler(rotation);
        }
    });
};

function TransformGizmoTranslate(handles) {

    TransformGizmo.call(this, handles);

    this.setActivePlane = function (axis, eye) {

        var tempMatrix = new THREE$1.Matrix4();
        eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

        if (axis === "X") {

            this.activePlane = this.planes["XY"];

            if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
        }

        if (axis === "Y") {

            this.activePlane = this.planes["XY"];

            if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
        }

        if (axis === "Z") {

            this.activePlane = this.planes["XZ"];

            if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
        }

        if (axis === "XYZ") this.activePlane = this.planes["XYZE"];

        if (axis === "XY") this.activePlane = this.planes["XY"];

        if (axis === "YZ") this.activePlane = this.planes["YZ"];

        if (axis === "XZ") this.activePlane = this.planes["XZ"];
    };

    this.init();
}

TransformGizmoTranslate.prototype = Object.create(TransformGizmo.prototype);
TransformGizmoTranslate.prototype.constructor = TransformGizmoTranslate;

function TransformGizmoRotate(handles) {

    TransformGizmo.call(this, handles);

    this.setActivePlane = function (axis) {

        if (axis === "E") this.activePlane = this.planes["XYZE"];

        if (axis === "X") this.activePlane = this.planes["YZ"];

        if (axis === "Y") this.activePlane = this.planes["XZ"];

        if (axis === "Z") this.activePlane = this.planes["XY"];
    };

    this.update = function (rotation, eye2) {

        TransformGizmo.prototype.update.apply(this, arguments);

        var group = {

            handles: this["handles"]

        };

        var tempMatrix = new THREE$1.Matrix4();
        var worldRotation = new THREE$1.Euler(0, 0, 1);
        var tempQuaternion = new THREE$1.Quaternion();
        var unitX = new THREE$1.Vector3(1, 0, 0);
        var unitY = new THREE$1.Vector3(0, 1, 0);
        var unitZ = new THREE$1.Vector3(0, 0, 1);
        var quaternionX = new THREE$1.Quaternion();
        var quaternionY = new THREE$1.Quaternion();
        var quaternionZ = new THREE$1.Quaternion();
        var eye = eye2.clone();

        worldRotation.copy(this.planes["XY"].rotation);
        tempQuaternion.setFromEuler(worldRotation);

        tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);
        eye.applyMatrix4(tempMatrix);

        this.traverse(function (child) {

            tempQuaternion.setFromEuler(worldRotation);

            if (child.name === "X") {

                quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                child.quaternion.copy(tempQuaternion);
            }

            if (child.name === "Y") {

                quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
                child.quaternion.copy(tempQuaternion);
            }

            if (child.name === "Z") {

                quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
                child.quaternion.copy(tempQuaternion);
            }
        });
    };

    this.init();
}

TransformGizmoRotate.prototype = Object.create(TransformGizmo.prototype);
TransformGizmoRotate.prototype.constructor = TransformGizmoRotate;

function TransformGizmoScale(handles) {

    TransformGizmo.call(this, handles);

    this.setActivePlane = function (axis, eye) {

        var tempMatrix = new THREE$1.Matrix4();
        eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

        if (axis === "X") {

            this.activePlane = this.planes["XY"];
            if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
        }

        if (axis === "Y") {

            this.activePlane = this.planes["XY"];
            if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
        }

        if (axis === "Z") {

            this.activePlane = this.planes["XZ"];
            if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
        }

        if (axis === "XYZ") this.activePlane = this.planes["XYZE"];
    };

    this.init();
}

TransformGizmoScale.prototype = Object.create(TransformGizmo.prototype);
TransformGizmoScale.prototype.constructor = TransformGizmoScale;

function TransformControls(camera, domElement) {

    // TODO: Make non-uniform scale and rotate play nice in hierarchies
    // TODO: ADD RXYZ contol

    THREE$1.Object3D.call(this);

    domElement = domElement !== undefined ? domElement : document;

    this.defaultHandles = new DefaultHandles();

    this.object = undefined;
    this.visible = false;
    this.translationSnap = null;
    this.rotationSnap = null;
    this.space = "world";
    this.size = 1;
    this.axis = null;
    this.dragObject = false;

    var scope = this;

    var _mode = "translate";
    var _dragging = false;
    var _plane = "XY";
    var _gizmo = {
        "translate": new TransformGizmoTranslate(scope.defaultHandles.translateHandles()),
        "rotate": new TransformGizmoRotate(scope.defaultHandles.rotateHandles()),
        "scale": new TransformGizmoScale(scope.defaultHandles.scaleHandles())
    };

    for (var type in _gizmo) {

        var gizmoObj = _gizmo[type];

        gizmoObj.visible = type === _mode;
        this.add(gizmoObj);
    }

    var changeEvent = { type: "change" };
    var mouseDownEvent = { type: "mouseDown" };
    var mouseUpEvent = { type: "mouseUp", mode: _mode };
    var objectChangeEvent = { type: "objectChange" };

    var ray = new THREE$1.Raycaster();
    ray.linePrecision = 0.01;
    var pointerVector = new THREE$1.Vector2();

    var point = new THREE$1.Vector3();
    var offset = new THREE$1.Vector3();

    var rotation = new THREE$1.Vector3();
    var offsetRotation = new THREE$1.Vector3();
    var scale = 1;

    var lookAtMatrix = new THREE$1.Matrix4();
    var eye = new THREE$1.Vector3();

    var tempMatrix = new THREE$1.Matrix4();
    var tempVector = new THREE$1.Vector3();
    var tempQuaternion = new THREE$1.Quaternion();
    var unitX = new THREE$1.Vector3(1, 0, 0);
    var unitY = new THREE$1.Vector3(0, 1, 0);
    var unitZ = new THREE$1.Vector3(0, 0, 1);

    var quaternionXYZ = new THREE$1.Quaternion();
    var quaternionX = new THREE$1.Quaternion();
    var quaternionY = new THREE$1.Quaternion();
    var quaternionZ = new THREE$1.Quaternion();
    var quaternionE = new THREE$1.Quaternion();

    var oldPosition = new THREE$1.Vector3();
    var oldScale = new THREE$1.Vector3();
    var oldRotationMatrix = new THREE$1.Matrix4();

    var parentRotationMatrix = new THREE$1.Matrix4();
    var parentScale = new THREE$1.Vector3();

    var worldPosition = new THREE$1.Vector3();
    var worldRotation = new THREE$1.Euler();
    var worldRotationMatrix = new THREE$1.Matrix4();
    var camPosition = new THREE$1.Vector3();
    var camRotation = new THREE$1.Euler();

    domElement.addEventListener("mousedown", onPointerDown, false);
    domElement.addEventListener("touchstart", onPointerDown, false);

    domElement.addEventListener("mousemove", onPointerHover, false);
    domElement.addEventListener("touchmove", onPointerHover, false);

    domElement.addEventListener("mousemove", onPointerMove, false);
    domElement.addEventListener("touchmove", onPointerMove, false);

    domElement.addEventListener("mouseup", onPointerUp, false);
    domElement.addEventListener("mouseout", onPointerUp, false);
    domElement.addEventListener("touchend", onPointerUp, false);
    domElement.addEventListener("touchcancel", onPointerUp, false);
    domElement.addEventListener("touchleave", onPointerUp, false);

    this.dispose = function () {

        domElement.removeEventListener("mousedown", onPointerDown);
        domElement.removeEventListener("touchstart", onPointerDown);

        domElement.removeEventListener("mousemove", onPointerHover);
        domElement.removeEventListener("touchmove", onPointerHover);

        domElement.removeEventListener("mousemove", onPointerMove);
        domElement.removeEventListener("touchmove", onPointerMove);

        domElement.removeEventListener("mouseup", onPointerUp);
        domElement.removeEventListener("mouseout", onPointerUp);
        domElement.removeEventListener("touchend", onPointerUp);
        domElement.removeEventListener("touchcancel", onPointerUp);
        domElement.removeEventListener("touchleave", onPointerUp);
    };

    this.attach = function (object) {

        this.object = object;
        this.visible = true;
        this.update();
    };

    this.detach = function () {

        this.object = undefined;
        this.visible = false;
        this.axis = null;
    };

    this.getMode = function () {

        return _mode;
    };

    this.setMode = function (mode) {

        _mode = mode ? mode : _mode;

        if (_mode === "scale") scope.space = "local";

        for (var type in _gizmo) {
            _gizmo[type].visible = type === _mode;
        }this.update();
        scope.dispatchEvent(changeEvent);
    };

    this.setTranslationSnap = function (translationSnap) {

        scope.translationSnap = translationSnap;
    };

    this.setRotationSnap = function (rotationSnap) {

        scope.rotationSnap = rotationSnap;
    };

    this.setSize = function (size) {

        scope.size = size;
        this.update();
        scope.dispatchEvent(changeEvent);
    };

    this.setSpace = function (space) {

        scope.space = space;
        this.update();
        scope.dispatchEvent(changeEvent);
    };

    this.setHandles = function (mode, handles) {

        _gizmo[mode].setHandles(handles);
        scope.update();
        scope.dispatchEvent(changeEvent);
    };

    this.update = function () {

        if (scope.object === undefined) return;

        scope.object.updateMatrixWorld();
        worldPosition.setFromMatrixPosition(scope.object.matrixWorld);
        worldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));

        camera.updateMatrixWorld();
        camPosition.setFromMatrixPosition(camera.matrixWorld);
        camRotation.setFromRotationMatrix(tempMatrix.extractRotation(camera.matrixWorld));

        scale = worldPosition.distanceTo(camPosition) / 6 * scope.size;
        this.position.copy(worldPosition);
        this.scale.set(scale, scale, scale);

        if (camera instanceof THREE$1.PerspectiveCamera) {

            eye.copy(camPosition).sub(worldPosition).normalize();
        } else if (camera instanceof THREE$1.OrthographicCamera) {

            eye.copy(camPosition).normalize();
        }

        if (scope.space === "local") {

            _gizmo[_mode].update(worldRotation, eye);
        } else if (scope.space === "world") {

            _gizmo[_mode].update(new THREE$1.Euler(), eye);
        }

        _gizmo[_mode].highlight(scope.axis);
    };

    function onPointerHover(event) {

        if (scope.object === undefined || _dragging === true || _gizmo[_mode].handles === null || event.button !== undefined && event.button !== 0) return;

        var pointer = event.changedTouches ? event.changedTouches[0] : event;

        var intersect = intersectObjects(pointer, _gizmo[_mode].handles.children);

        var axis = null;

        if (intersect) {

            axis = intersect.object.name;

            event.preventDefault();
        }

        if (scope.axis !== axis) {

            scope.axis = axis;
            scope.update();
            scope.dispatchEvent(changeEvent);
        }
    }

    function onPointerDown(event) {

        if (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;

        var pointer = event.changedTouches ? event.changedTouches[0] : event;

        if (pointer.button === 0 || pointer.button === undefined) {

            if (_gizmo[_mode].handles !== null) {

                var intersect = intersectObjects(pointer, _gizmo[_mode].handles.children);

                if (!intersect) return;

                event.preventDefault();
                event.stopPropagation();

                scope.dispatchEvent(mouseDownEvent);

                scope.axis = intersect.object.name;
            }

            if (!scope.axis) return;

            scope.update();

            eye.copy(camPosition).sub(worldPosition).normalize();

            _gizmo[_mode].setActivePlane(scope.axis, eye);

            var planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);

            if (planeIntersect) {

                oldPosition.copy(scope.object.position);
                oldScale.copy(scope.object.scale);

                oldRotationMatrix.extractRotation(scope.object.matrix);
                worldRotationMatrix.extractRotation(scope.object.matrixWorld);

                parentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);
                parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));

                offset.copy(planeIntersect.point);
            }
        }

        _dragging = true;
    }

    function onPointerMove(event) {

        if (scope.object === undefined || scope.axis === null || _dragging === false || event.button !== undefined && event.button !== 0) return;

        var pointer = event.changedTouches ? event.changedTouches[0] : event;

        var planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);

        if (planeIntersect === false) return;

        event.preventDefault();
        event.stopPropagation();

        point.copy(planeIntersect.point);

        if (_mode === "translate") {

            point.sub(offset);
            point.multiply(parentScale);

            if (scope.space === "local") {

                point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

                if (scope.axis.search("X") === -1) point.x = 0;
                if (scope.axis.search("Y") === -1) point.y = 0;
                if (scope.axis.search("Z") === -1) point.z = 0;

                point.applyMatrix4(oldRotationMatrix);

                scope.object.position.copy(oldPosition);
                scope.object.position.add(point);
            }

            if (scope.space === "world" || scope.axis.search("XYZ") !== -1) {

                if (scope.axis.search("X") === -1) point.x = 0;
                if (scope.axis.search("Y") === -1) point.y = 0;
                if (scope.axis.search("Z") === -1) point.z = 0;

                point.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));

                scope.object.position.copy(oldPosition);
                scope.object.position.add(point);
            }

            if (scope.translationSnap !== null) {

                if (scope.space === "local") {

                    scope.object.position.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
                }

                if (scope.axis.search("X") !== -1) scope.object.position.x = Math.round(scope.object.position.x / scope.translationSnap) * scope.translationSnap;
                if (scope.axis.search("Y") !== -1) scope.object.position.y = Math.round(scope.object.position.y / scope.translationSnap) * scope.translationSnap;
                if (scope.axis.search("Z") !== -1) scope.object.position.z = Math.round(scope.object.position.z / scope.translationSnap) * scope.translationSnap;

                if (scope.space === "local") {

                    scope.object.position.applyMatrix4(worldRotationMatrix);
                }
            }
        } else if (_mode === "scale") {

            point.sub(offset);
            point.multiply(parentScale);

            if (scope.space === "local") {

                if (scope.axis === "XYZ") {

                    scale = 1 + point.y / Math.max(oldScale.x, oldScale.y, oldScale.z);

                    scope.object.scale.x = oldScale.x * scale;
                    scope.object.scale.y = oldScale.y * scale;
                    scope.object.scale.z = oldScale.z * scale;
                } else {

                    point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

                    if (scope.axis === "X") scope.object.scale.x = oldScale.x * (1 + point.x / oldScale.x);
                    if (scope.axis === "Y") scope.object.scale.y = oldScale.y * (1 + point.y / oldScale.y);
                    if (scope.axis === "Z") scope.object.scale.z = oldScale.z * (1 + point.z / oldScale.z);
                }
            }
        } else if (_mode === "rotate") {

            point.sub(worldPosition);
            point.multiply(parentScale);
            tempVector.copy(offset).sub(worldPosition);
            tempVector.multiply(parentScale);

            if (scope.axis === "E") {

                point.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
                tempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));

                rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

                tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

                quaternionE.setFromAxisAngle(eye, rotation.z - offsetRotation.z);
                quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

                scope.object.quaternion.copy(tempQuaternion);
            } else if (scope.axis === "XYZE") {

                quaternionE.setFromEuler(point.clone().cross(tempVector).normalize()); // rotation axis

                tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));
                quaternionX.setFromAxisAngle(quaternionE, -point.clone().angleTo(tempVector));
                quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

                scope.object.quaternion.copy(tempQuaternion);
            } else if (scope.space === "local") {

                point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

                tempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

                rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

                quaternionXYZ.setFromRotationMatrix(oldRotationMatrix);

                if (scope.rotationSnap !== null) {

                    quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
                    quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
                    quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
                } else {

                    quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
                    quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
                    quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
                }

                if (scope.axis === "X") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);
                if (scope.axis === "Y") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);
                if (scope.axis === "Z") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);

                scope.object.quaternion.copy(quaternionXYZ);
            } else if (scope.space === "world") {

                rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

                tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

                if (scope.rotationSnap !== null) {

                    quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
                    quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
                    quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
                } else {

                    quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
                    quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
                    quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
                }

                quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

                if (scope.axis === "X") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                if (scope.axis === "Y") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
                if (scope.axis === "Z") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);

                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

                scope.object.quaternion.copy(tempQuaternion);
            }
        }

        scope.update();
        scope.dispatchEvent(changeEvent);
        scope.dispatchEvent(objectChangeEvent);
    }

    function onPointerUp(event) {

        event.preventDefault(); // Prevent MouseEvent on mobile

        if (event.button !== undefined && event.button !== 0) return;

        if (_dragging && scope.axis !== null) {

            mouseUpEvent.mode = _mode;
            scope.dispatchEvent(mouseUpEvent);
        }

        _dragging = false;

        if ('TouchEvent' in window && event instanceof TouchEvent) {

            // Force "rollover"

            scope.axis = null;
            scope.update();
            scope.dispatchEvent(changeEvent);
        } else {

            onPointerHover(event);
        }
    }

    function intersectObjects(pointer, objects) {

        var rect = domElement.getBoundingClientRect();
        var x = (pointer.clientX - rect.left) / rect.width;
        var y = (pointer.clientY - rect.top) / rect.height;

        pointerVector.set(x * 2 - 1, -(y * 2) + 1);
        ray.setFromCamera(pointerVector, camera);

        var intersections = ray.intersectObjects(objects, true);
        return intersections[0] ? intersections[0] : false;
    }
}

TransformControls.prototype = Object.create(THREE$1.Object3D.prototype);
TransformControls.prototype.constructor = TransformControls;

/**
 * @author kennethjiang / https://github.com/kennethjiang
 *
 *
 * Description: A THREE view port for STL models
 *
 * Usage:
 *  var viewPort = new THREE.STLViewPort(canvas, width, height, function() {
 *     //things to do when any model in the view port changes
 *  });
 *  viewPort.init();
 *  viewPort.loadSTL(url, fucntion(model) {
 *     viewPort.makeModelActive(model);
 *     //things to do when model is loaded
 *  });
 *  var scene = viewPort.scene; // direct access to the scene for to add THREE.Object
 *
 */

function STLViewPort(canvas, width, height, onChange, onNewModel) {

    var self = this;

    self.canvas = canvas;
    self.canvasWidth = width;
    self.canvasHeight = height;
    self.onChange = onChange;
    self.onNewModel = onNewModel;

    self.models = [];

    self.effectController = {
        metalness: 0.5,
        roughness: 0.5,
        modelInactiveColor: new THREE.Color("#60715b"),
        modelActiveColor: new THREE.Color("#34bf0d"),
        ambientLightColor: new THREE.Color("#2b2b2b"),
        directionalLightColor: new THREE.Color("#ffffff")
    };

    self.init = function () {

        self.camera = new THREE.PerspectiveCamera(45, 1.0, 0.1, 5000);

        self.camera.up.set(0, 0, 1);
        self.camera.position.set(-100, -200, 250);

        self.scene = new THREE.Scene();

        // Lights
        var ambientLight = new THREE.AmbientLight(self.effectController.ambientLightColor); // 0.2
        self.scene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(self.effectController.directionalLightColor, 1.0);
        directionalLight.position.set(100, 100, 500);
        self.scene.add(directionalLight);
        var directionalLight2 = new THREE.DirectionalLight(self.effectController.directionalLightColor, 1.0);
        directionalLight2.position.set(100, 100, -500);
        self.scene.add(directionalLight2);

        self.renderer = new THREE.WebGLRenderer({ canvas: self.canvas, antialias: true });

        self.renderer.setClearColor(0xd8d8d8);
        self.renderer.setSize(self.canvasWidth, self.canvasHeight);
        self.renderer.setPixelRatio(window.devicePixelRatio);

        self.renderer.gammaInput = true;
        self.renderer.gammaOutput = true;

        self.orbitControls = new THREE.OrbitControls(self.camera, self.renderer.domElement);

        self.orbitControls.enableDamping = true;
        self.orbitControls.dampingFactor = 0.25;
        self.orbitControls.enablePan = false;
        self.orbitControls.addEventListener("change", self.render);

        self.transformControls = new TransformControls(self.camera, self.renderer.domElement);

        self.transformControls.setRotationSnap(THREE.Math.degToRad(15));
        self.transformControls.addEventListener("change", self.render);
        self.transformControls.addEventListener("mouseDown", self.startTransform);
        self.transformControls.addEventListener("mouseUp", self.endTransform);
        self.transformControls.addEventListener("change", self.onChange);
        self.scene.add(self.transformControls);

        window.addEventListener('keydown', function (event) {
            switch (event.keyCode) {
                case 17:
                    // Ctrl
                    self.transformControls.setRotationSnap(null);
                    break;
            }
        });

        window.addEventListener('keyup', function (event) {
            switch (event.keyCode) {
                case 17:
                    // Ctrl
                    self.transformControls.setRotationSnap(THREE.Math.degToRad(15));
                    break;
            }
        });

        // Unforutnately built-in "click" event is fired when it's a drag. We need all these complexity to detect real click (no mousemoves between mousedown and mouseup)
        self.canvas.addEventListener("mousedown", function () {
            self.lastMouseEvent = "mousedown";
        });
        self.canvas.addEventListener("mousemove", function () {
            self.lastMouseEvent = "mousemove";
        });
        self.canvas.addEventListener("mouseup", function (e) {
            if (self.lastMouseEvent == "mousedown") self.pickActiveModel(e);
        });

        self.render();
    };

    self.render = function () {
        self.orbitControls.update();
        self.transformControls.update();
        self.renderer.render(self.scene, self.camera);
    };

    self.loadSTL = function (url, onLoad) {
        new THREE.STLLoader().load(url, function (geometry) {
            self.onNewModel([self.addModelOfGeometry(geometry)]);
        });
    };

    self.addModelOfGeometry = function (geometry, modelToCopyTransformFrom) {
        var material = new THREE.MeshStandardMaterial({
            color: self.effectController.modelInactiveColor, // We'll mark it active below.
            shading: THREE.SmoothShading,
            side: THREE.DoubleSide,
            metalness: self.effectController.metalness,
            roughness: self.effectController.roughness });

        var stlModel = new THREE.Mesh(geometry, material);

        // center model's origin
        var center = new THREE.Box3().setFromObject(stlModel).center();
        var model = new THREE.Object3D();
        model.add(stlModel);
        stlModel.position.copy(center.negate());
        if (modelToCopyTransformFrom) {
            model.rotation.copy(modelToCopyTransformFrom.rotation);
            model.scale.copy(modelToCopyTransformFrom.scale);
        }

        self.scene.add(model);
        self.render();

        self.models.push(model);
        return model;
    };

    self.activeModel = function () {
        return self.transformControls.object;
    };

    self.pickActiveModel = function (event) {
        var rect = self.canvas.getBoundingClientRect();
        var x = (event.clientX - rect.left) / rect.width;
        var y = (event.clientY - rect.top) / rect.height;

        var pointerVector = new THREE.Vector2();
        pointerVector.set(x * 2 - 1, -(y * 2) + 1);
        var ray = new THREE.Raycaster();
        ray.setFromCamera(pointerVector, self.camera);

        // Clicking should cycle through the stlFiles if there are multiple under the cursor.
        var foundActiveModel = false;
        var nextPointedModel = undefined;
        var firstPointedModel = undefined;
        for (var i = 0; i < self.models.length; i++) {
            var model = self.models[i];
            var intersections = ray.intersectObjects(model.children, true); // Not sure why ray will intersect the children but not the model itself.
            if (!intersections[0]) {
                continue;
            }
            if (!firstPointedModel) {
                firstPointedModel = model;
            }
            if (foundActiveModel && !nextPointedModel) {
                nextPointedModel = model;
            }
            if (self.activeModel() == model) {
                foundActiveModel = true;
            }
        }
        if (nextPointedModel) {
            self.makeModelActive(nextPointedModel);
        } else if (firstPointedModel) {
            self.makeModelActive(firstPointedModel);
        }
    };

    /**
     * params:
     *    m: model to make active. Clear active model if m is undefined
     *
     */
    self.makeModelActive = function (m) {
        // Sets one file active and inactivates all the others.
        if (m) {
            self.transformControls.attach(m);
        } else {
            self.transformControls.detach();
        }

        for (var i = 0; i < self.models.length; i++) {
            var model = self.models[i];
            if (model == self.activeModel()) {
                model.children[0].material.color.copy(self.effectController.modelActiveColor);
            } else {
                model.children[0].material.color.copy(self.effectController.modelInactiveColor);
            }
        }

        self.render();
        self.onChange();
    };

    self.removeActiveModel = function () {
        if (!self.activeModel()) {
            return undefined;
        } else {
            var model = self.activeModel();

            var index = self.models.indexOf(model);
            if (index > -1) {
                self.models.splice(index, 1);
            }

            self.scene.remove(model);
            self.makeModelActive(undefined);
            return model;
        }
    };

    self.removeAllModels = function () {
        for (var i = 0; i < self.models.length; i++) {
            self.scene.remove(self.models[i]);
        }
        self.models = [];
        self.makeModelActive(undefined);
    };

    self.splitActiveModel = function () {
        if (!self.activeModel()) {
            return;
        } else {
            var originalModel = self.removeActiveModel();
            var geometry = originalModel.children[0].geometry;
            var newGeometries = GeometryUtils.split(geometry);
            self.onNewModel(newGeometries.map(function (geometry) {
                return self.addModelOfGeometry(geometry, originalModel);
            }));
        }
    };

    self.onlyOneOriginalModel = function () {
        return self.models.length == 1 && self.models[0].position.x == 0.0 && self.models[0].position.y == 0.0 && self.models[0].rotation.x == 0.0 && self.models[0].rotation.y == 0.0 && self.models[0].rotation.z == 0.0 && self.models[0].scale.x == 1.0 && self.models[0].scale.y == 1.0 && self.models[0].scale.z == 1.0;
    };

    self.startTransform = function () {
        // Disable orbit controls
        self.orbitControls.enabled = false;
    };

    self.endTransform = function () {
        // Enable orbit controls
        self.orbitControls.enabled = true;
    };
}

/*
 * View model for OctoPrint-Slicer
 *
 * Author: Kenneth Jiang
 * License: AGPLv3
 */
ko.bindingHandlers.numericValue = {
    init: function init(element, valueAccessor, allBindings, data, context) {
        var interceptor = ko.computed({
            read: function read() {
                return ko.unwrap(valueAccessor());
            },
            write: function write(value) {
                if (!isNaN(value)) {
                    valueAccessor()(parseFloat(value));
                }
            },
            disposeWhenNodeIsRemoved: element
        });

        ko.applyBindingsToNode(element, { value: interceptor }, context);
    }
};

function OverridesViewModel(parameters, array_keys, enum_keys, item_keys, boolean_keys) {
    var self = this;
    self.slicingViewModel = parameters[0];

    var ARRAY_KEYS = ["print_temperature", "start_gcode", "end_gcode", "filament_diameter"],
        ENUM_KEYS = {
        "support": ko.observableArray(["none", "buildplate", "everywhere"]),
        "platform_adhesion": ko.observableArray(["none", "brim", "raft"])
    },
        ITEM_KEYS = ["layer_height", "temperature", "bed_temperature", "print_bed_temperature", "fill_density", "wall_thickness", "print_speed", "solid_layer_thickness", "travel_speed", "outer_shell_speed", "inner_shell_speed", "infill_speed", "bottom_layer_speed", "filament_flow", "retraction_speed", "retraction_amount", "extrusion_multiplier"],
        BOOLEAN_KEYS = ["support_material", "overhangs", "retraction_enable", "fan_enabled", "cooling"];
    var ALL_KEYS = BOOLEAN_KEYS.concat(ITEM_KEYS).concat(ARRAY_KEYS).concat(Object.keys(ENUM_KEYS));

    // initialize all observables
    _.forEach(ALL_KEYS, function (k) {
        self["profile." + k] = ko.observable();
    });

    self.optionsForKey = function (key) {
        return ENUM_KEYS[key];
    };

    self.updateOverridesFromProfile = function (profile) {

        // Some options are numeric but might have a percent sign after them.
        // Remove the percent and save it to replace later.
        self.endings = {};
        var stripEndings = function stripEndings(m, k) {
            if (_.isString(m[k]) && m[k].endsWith("%")) {
                self.endings[k] = "%";
                return m[k].slice(0, -1);
            } else {
                return m[k];
            }
        };

        // Some options are booleans but can be stored as 0/1 or false/true.
        // Convert to native true/false and keep track of the style.
        self.booleans = {};
        var convertBoolean = function convertBoolean(m, k) {
            var BOOLS = [["false", "true"], ["False", "True"], ["0", "1"]];
            if (m[k] === undefined) {
                return undefined;
            }
            for (var boolType = 0; boolType < BOOLS.length; boolType++) {
                for (var b = 0; b < BOOLS[boolType].length; b++) {
                    if (m[k] === BOOLS[boolType][b]) {
                        self.booleans[k] = BOOLS[boolType];
                        return !!b; // Convert 0 to false and 1 to true.
                    }
                }
            }
            return !!m[k]; // Just take a guess if we can't figure it out.
        };

        // Some options are arrays in cura but not Slic3r.  Keep track of which.
        self.isArray = [];

        _.forEach(ITEM_KEYS, function (k) {
            self["profile." + k](stripEndings(profile, k));
        });
        _.forEach(BOOLEAN_KEYS, function (k) {
            self["profile." + k](convertBoolean(profile, k));
        });
        _.forEach(ENUM_KEYS, function (v, k) {
            self["profile." + k](profile[k]);
        });
        _.forEach(ARRAY_KEYS, function (k) {
            // Some config options are arrays in cura but not in Slic3r.
            // Detect which ones are arrays and only convert those.
            if (_.isArray(profile[k])) {
                self.isArray.push(k); // Remember this for later.
                self["profile." + k](profile[k][0]);
            } else {
                self["profile." + k](profile[k]);
            }
        });
    };

    self.onProfileChange = function (newValue) {
        if (newValue === undefined) {
            // For some reason KO would fire event with newValue=undefined,
            return; // in which case we should ignore it otherwise things get messed up
        }

        var slicing = self.slicingViewModel;

        if (!slicing.slicer() || !slicing.profile()) {
            return;
        }

        self.fetchSlicingProfile(slicing.slicer(), slicing.profile());
    };

    self.fetchSlicingProfile = function (slicer, profile) {
        if (self.profileAjax) {
            self.profileAjax.abort();
            self.profileAjax = undefined;
        }

        self.profileAjax = $.ajax({
            url: API_BASEURL + "slicing/" + slicer + "/profiles/" + profile,
            type: "GET",
            // On success
            success: function success(data) {
                self.updateOverridesFromProfile(data.data);
            }
        });
    };

    self.slicingViewModel.profile.subscribe(self.onProfileChange);
    //
    //End of Profile-handling mess


    self.toJS = function () {
        var result = ko.mapping.toJS(self, {
            ignore: ["slicingViewModel", "updateOverridesFromProfile", "updateOverrides", "toJS", "optionsForKey", "stripEndings", "isArray", "endings"]
        });
        _.forEach(ITEM_KEYS, function (k) {
            if (self.endings.hasOwnProperty(k)) {
                result["profile." + k] += self.endings[k];
            }
        });
        _.forEach(BOOLEAN_KEYS, function (k) {
            if (self.booleans.hasOwnProperty(k)) {
                // Convert false/true to the correct string.
                result["profile." + k] = self.booleans[k][result["profile." + k] ? 1 : 0];
            }
        });

        for (var key in result) {
            var baseKey = key.replace("profile.", "");
            // Convert it back to an array if it was an array originally.
            if (_.contains(ARRAY_KEYS, baseKey) && _.contains(self.isArray, baseKey)) {
                result[key] = [result[key]];
            }
        }

        _.forEach(result, function (k) {
            // If the value is undefined, must not be valid for this slicer.
            if (result[k] === undefined) {
                delete result[k];
            }
        });
        return result;
    };
}

// view model class, parameters for constructor, container to bind to
OCTOPRINT_VIEWMODELS.push([OverridesViewModel, ["slicingViewModel"], ["#basic_overrides", "#advanced_overrides"]]);

/*
 * View model for OctoPrint-Slicer
 *
 * Author: Kenneth Jiang
 * License: AGPLv3
 */

if (window.location.hostname != "localhost") {
    Raven.config('https://85bd9314656d40da9249aec5a32a2b52@sentry.io/141297', {
        release: '0.9.6',
        ignoreErrors: ["Failed to execute 'arc' on 'CanvasRenderingContext2D': The radius provided", "Cannot read property 'highlightFill' of undefined", "Argument 1 of SVGMatrix.translate is not a finite floating-point value", /_jp.*is not a function/]
    }).install();
}

function SlicerViewModel(parameters) {
    mixpanel.track("App Loaded");

    var self = this;

    self.canvas = document.getElementById('slicer-canvas');

    //check if webGL is present. If not disable Slicer plugin
    if (!Detector.webgl) {
        $('#tab_plugin_slicer').empty().append("<h3>Slicer Plugin is disabled because your browser doesn't support WebGL</h3>");
        return;
    }

    // assign the injected parameters, e.g.:
    self.slicingViewModel = parameters[0];
    self.overridesViewModel = parameters[1];
    self.printerStateViewModel = parameters[2];
    self.printerProfilesViewModel = parameters[3];

    self.lockScale = true;
    self.selectedSTL = undefined;
    self.newPrint = true;

    // Override slicingViewModel.show to surpress default slicing behavior
    self.slicingViewModel.show = function (target, file, force) {
        if (!self.slicingViewModel.enableSlicingDialog() && !force) {
            return;
        }
        mixpanel.track("Load STL");

        $('a[href="#tab_plugin_slicer"]').tab('show');

        self.selectedSTL = { target: target, file: file };
        if (self.newPrint) {
            self.addToNewPrint();
        } else {
            $("#plugin-slicer-load-model").modal("show");
        }
    };

    self.addToNewPrint = function () {
        self.clearPrint();
        self.addToExistingPrint();
    };

    self.addToExistingPrint = function () {
        self.setSlicingViewModel(self.selectedSTL.target, self.selectedSTL.file);
        self.addSTL(self.selectedSTL.target, self.selectedSTL.file);
        self.selectedSTL = undefined;

        $("#plugin-slicer-load-model").modal("hide");
    };

    self.clearPrint = function () {
        self.resetSlicingViewModel();
        self.stlViewPort.removeAllModels();
        self.newPrint = true;
    };

    self.addSTL = function (target, file) {
        self.newPrint = false;
        self.stlViewPort.loadSTL(BASEURL + "downloads/files/" + target + "/" + file);
    };

    self.onModelAdd = function (models) {

        self.stlViewPort.makeModelActive(models[0]);

        models.forEach(function (model) {
            self.fixZPosition(model);
        });

        if (self.stlViewPort.models.length > 1) {
            ModelArranger.arrange(self.stlViewPort.models);
        }
        self.stlViewPort.render();

        $('#tab_plugin_slicer > div.translucent-blocker').hide();
    };

    self.onModelRemove = function (model) {
        if (self.stlViewPort.models.length == 0) {
            self.clearPrint();
        }
    };

    self.updatePrinterBed = function (profileName) {
        if (profileName) {
            var profile = self.printerProfilesViewModel.profiles.items().find(function (p) {
                return p.id == profileName;
            });

            var dim = profile.volume;
            self.BEDSIZE_X_MM = dim.width;
            self.BEDSIZE_Y_MM = dim.depth;
            self.BEDSIZE_Z_MM = dim.height;
            if (dim.origin == "lowerleft") {
                self.ORIGIN_OFFSET_X_MM = self.BEDSIZE_X_MM / 2.0;
                self.ORIGIN_OFFSET_Y_MM = self.BEDSIZE_Y_MM / 2.0;
            } else {
                self.ORIGIN_OFFSET_X_MM = 0;
                self.ORIGIN_OFFSET_Y_MM = 0;
            }
        }
        self.drawBedFloor(self.BEDSIZE_X_MM, self.BEDSIZE_Y_MM);
        self.drawWalls(self.BEDSIZE_X_MM, self.BEDSIZE_Y_MM, self.BEDSIZE_Z_MM);
        self.stlViewPort.render();
    };

    self.slicingViewModel.printerProfile.subscribe(self.updatePrinterBed);

    self.BEDSIZE_X_MM = 200;
    self.BEDSIZE_Y_MM = 200;
    self.BEDSIZE_Z_MM = 200;
    self.ORIGIN_OFFSET_X_MM = 0;
    self.ORIGIN_OFFSET_Y_MM = 0;

    var CANVAS_WIDTH = 588,
        CANVAS_HEIGHT = 588;

    self.init = function () {

        self.slicingViewModel.requestData();

        self.stlViewPort = new STLViewPort(self.canvas, CANVAS_WIDTH, CANVAS_HEIGHT, self.onModelChange, self.onModelAdd);
        self.stlViewPort.init();

        //Walls and Floor
        self.walls = new THREE.Object3D();
        self.floor = new THREE.Object3D();
        self.stlViewPort.scene.add(self.walls);
        self.stlViewPort.scene.add(self.floor);

        self.updatePrinterBed();

        ko.applyBindings(self.slicingViewModel, $('#slicing-settings')[0]);

        // Buttons on the canvas, and their behaviors.
        // TODO: it's not DRY. mix of prez code and logics. need to figure out a better way
        $("#slicer-viewport").empty().append('<div class="report"><span>Got issues or suggestions? <a target="_blank" href="https://github.com/kennethjiang/OctoPrint-Slicer/issues/new">Click here!</a></span></div>\
                  <div class="model">\
                    <button class="translate disabled" title="Move"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/translate.png"></button>\
                    <button class="rotate disabled" title="Rotate"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/rotate.png"></button>\
                    <button class="scale disabled" title="Scale"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/scale.png"></button>\
                    <button class="remove disabled" title="Remove"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/remove.png"></button>\
                    <button class="split disabled" title="Split"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/split.png"></button>\
                </div>\
                <div class="values translate">\
                    <div>\
                        <p><span class="axis x">X</span><input type="number" step="any" name="x"><span title="">mm</span></p>\
                        <p><span class="axis y">Y</span><input type="number" step="any" name="y"><span title="">mm</span></p>\
                        <span></span>\
                    </div>\
               </div>\
                <div class="values rotate">\
                    <div>\
                        <p><span class="axis x">X</span><input type="number" step="any" name="x"><span title="">°</span></p>\
                        <p><span class="axis y">Y</span><input type="number" step="any" name="y"><span title="">°</span></p>\
                        <p><span class="axis z">Z</span><input type="number" step="any" name="z"><span title="">°</span></p>\
                        <span></span>\
                    </div>\
               </div>\
                <div class="values scale">\
                    <div>\
                        <p><span class="axis x">X</span><input type="number" step="0.001" name="x" min="0.001"></p>\
                        <p><span class="axis y">Y</span><input type="number" step="0.001" name="y" min="0.001"></p>\
                        <p><span class="axis z">Z</span><input type="number" step="0.001" name="z" min="0.001"></p>\
                        <p class="checkbox"><label><input type="checkbox" checked>Lock</label></p>\
                        <span></span>\
                    </div>\
               </div>');

        $("#slicer-viewport").append(self.stlViewPort.renderer.domElement);

        $("#slicer-viewport button.translate").click(function (event) {
            self.stlViewPort.transformControls.setMode("translate");
            self.stlViewPort.transformControls.space = "world";
            self.toggleValueInputs($("#slicer-viewport .translate.values div"));
        });
        $("#slicer-viewport button.rotate").click(function (event) {
            self.stlViewPort.transformControls.setMode("rotate");
            self.stlViewPort.transformControls.space = "world";
            self.toggleValueInputs($("#slicer-viewport .rotate.values div"));
        });
        $("#slicer-viewport button.scale").click(function (event) {
            self.stlViewPort.transformControls.setMode("scale");
            self.stlViewPort.transformControls.space = "local";
            self.toggleValueInputs($("#slicer-viewport .scale.values div"));
        });
        $("#slicer-viewport button.remove").click(function (event) {
            self.onModelRemove(self.stlViewPort.removeActiveModel());
        });
        $("#slicer-viewport button.split").click(function (event) {
            self.onModelRemove(self.stlViewPort.splitActiveModel());
        });
        $("#slicer-viewport .values input").change(function () {
            self.applyValueInputs($(this));
        });
    };

    self.toggleValueInputs = function (parentDiv) {
        if (parentDiv.hasClass("show")) {
            parentDiv.removeClass("show").children('p').removeClass("show");
        } else if (self.stlViewPort.activeModel()) {
            $("#slicer-viewport .values div").removeClass("show");
            parentDiv.addClass("show").children('p').addClass("show");
        }
    };

    self.applyValueInputs = function (input) {
        input.blur();
        if (input[0].type == "checkbox") {
            self.lockScale = input[0].checked;
        } else if (input[0].type == "number" && !isNaN(parseFloat(input.val()))) {
            input.val(parseFloat(input.val()).toFixed(3));
            var model = self.stlViewPort.activeModel();

            if (input.closest(".values").hasClass("scale") && self.lockScale) {
                $("#slicer-viewport .scale.values input").val(input.val());
                console.log($("#slicer-viewport .scale.values input[name=\"x\"]").val());
            }

            model.position.x = parseFloat($("#slicer-viewport .translate.values input[name=\"x\"]").val());
            model.position.y = parseFloat($("#slicer-viewport .translate.values input[name=\"y\"]").val());
            model.rotation.x = THREE.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"x\"]").val());
            model.rotation.y = THREE.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"y\"]").val());
            model.rotation.z = THREE.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"z\"]").val());
            model.scale.x = parseFloat($("#slicer-viewport .scale.values input[name=\"x\"]").val());
            model.scale.y = parseFloat($("#slicer-viewport .scale.values input[name=\"y\"]").val());
            model.scale.z = parseFloat($("#slicer-viewport .scale.values input[name=\"z\"]").val());
            self.fixZPosition(model);
            self.stlViewPort.render();
        }
    };

    self.fixZPosition = function (model) {
        var bedLowMinZ = 0.0;
        var boundaryBox = new THREE.Box3().setFromObject(model);
        boundaryBox.min.sub(model.position);
        boundaryBox.max.sub(model.position);
        model.position.z -= model.position.z + boundaryBox.min.z - bedLowMinZ;
    };

    // callback function when models are changed by TransformControls
    self.onModelChange = function () {
        var model = self.stlViewPort.activeModel();
        if (model) {
            $("#slicer-viewport .translate.values input[name=\"x\"]").val(model.position.x.toFixed(3)).attr("min", '');
            $("#slicer-viewport .translate.values input[name=\"y\"]").val(model.position.y.toFixed(3)).attr("min", '');
            $("#slicer-viewport .rotate.values input[name=\"x\"]").val((model.rotation.x * 180 / Math.PI).toFixed(3)).attr("min", '');
            $("#slicer-viewport .rotate.values input[name=\"y\"]").val((model.rotation.y * 180 / Math.PI).toFixed(3)).attr("min", '');
            $("#slicer-viewport .rotate.values input[name=\"z\"]").val((model.rotation.z * 180 / Math.PI).toFixed(3)).attr("min", '');
            $("#slicer-viewport .scale.values input[name=\"x\"]").val(model.scale.x.toFixed(3)).attr("min", '');
            $("#slicer-viewport .scale.values input[name=\"y\"]").val(model.scale.y.toFixed(3)).attr("min", '');
            $("#slicer-viewport .scale.values input[name=\"z\"]").val(model.scale.z.toFixed(3)).attr("min", '');
            $("#slicer-viewport .scale.values input[type=\"checkbox\"]").checked = self.lockScale;
            self.fixZPosition(model);
            self.stlViewPort.render();
        }

        if (!self.stlViewPort.activeModel()) {
            $("#slicer-viewport .values div").removeClass("show");
            $("#slicer-viewport button").addClass("disabled");
        } else {
            $("#slicer-viewport button").removeClass("disabled");
        }
    };

    // Slicing
    //
    self.tempFiles = {};
    self.removeTempFilesAfterSlicing = function (event) {
        if ($.inArray(event.data.type, ["SlicingDone", "SlicingFailed"]) >= 0 && event.data.payload.stl in self.tempFiles) {
            OctoPrint.files.delete(event.data.payload.stl_location, event.data.payload.stl);
            delete self.tempFiles[event.data.payload.stl];
        }
    };

    OctoPrint.socket.onMessage("event", self.removeTempFilesAfterSlicing);

    self.sliceRequestData = function (slicingVM, group) {
        var destinationFilename = slicingVM._sanitize(slicingVM.destinationFilename());

        var destinationExtensions = slicingVM.data[slicingVM.slicer()] && slicingVM.data[slicingVM.slicer()].extensions && slicingVM.data[slicingVM.slicer()].extensions.destination ? slicingVM.data[slicingVM.slicer()].extensions.destination : ["???"];
        if (!_.any(destinationExtensions, function (extension) {
            return _.endsWith(destinationFilename.toLowerCase(), "." + extension.toLowerCase());
        })) {
            destinationFilename = destinationFilename + "." + destinationExtensions[0];
        }
        var groupCenter = new THREE.Vector3(0, 0, 0);
        if (group) {
            groupCenter = new THREE.Box3().setFromObject(group).center();
        }
        var data = {
            command: "slice",
            slicer: slicingVM.slicer(),
            profile: slicingVM.profile(),
            printerProfile: slicingVM.printerProfile(),
            destination: destinationFilename,
            position: { "x": self.ORIGIN_OFFSET_X_MM + groupCenter.x,
                "y": self.ORIGIN_OFFSET_Y_MM + groupCenter.y }
        };
        _.extend(data, self.overridesViewModel.toJS());

        if (slicingVM.afterSlicing() == "print") {
            data["print"] = true;
        } else if (slicingVM.afterSlicing() == "select") {
            data["select"] = true;
        }
        return data;
    };

    self.sendSliceRequest = function (target, filename, data) {
        $.ajax({
            url: API_BASEURL + "files/" + target + "/" + filename,
            type: "POST",
            dataType: "json",
            contentType: "application/json; charset=UTF-8",
            data: JSON.stringify(data),
            error: function error(jqXHR, textStatus) {
                new PNotify({ title: "Slicing failed", text: textStatus, type: "error", hide: false });
            }
        });
    };

    self.slice = function () {
        mixpanel.track("Slice Model");

        var target = self.slicingViewModel.target;
        var sliceRequestData;

        if (self.stlViewPort.onlyOneOriginalModel()) {

            sliceRequestData = self.sliceRequestData(self.slicingViewModel);
            self.sendSliceRequest(self.slicingViewModel.target, self.slicingViewModel.file(), sliceRequestData);
        } else {

            var form = new FormData();
            var group = new THREE.Group();
            _.forEach(self.stlViewPort.models, function (model) {
                group.add(model.clone(true));
            });

            sliceRequestData = self.sliceRequestData(self.slicingViewModel, group);

            var tempFilename = self.tempSTLFilename();
            form.append("file", self.blobFromModel(group), tempFilename);
            $.ajax({
                url: API_BASEURL + "files/local",
                type: "POST",
                data: form,
                processData: false,
                contentType: false,
                // On success
                success: function success(_) {
                    self.tempFiles[tempFilename] = 1;
                    self.sendSliceRequest(target, tempFilename, sliceRequestData);
                },
                error: function error(jqXHR, textStatus) {
                    new PNotify({ title: "Slicing failed", text: textStatus, type: "error", hide: false });
                }
            });
        }
    };

    self.blobFromModel = function (model) {
        var exporter = new THREE.STLBinaryExporter();
        return new Blob([exporter.parse(model)], { type: "text/plain" });
    };

    self.isPrinting = ko.computed(function () {
        return self.printerStateViewModel.isPrinting() || self.printerStateViewModel.isPaused();
    });

    self.canSliceNow = ko.computed(function () {
        // TODO: We should be checking for same_device here, too.
        return self.slicingViewModel.enableSliceButton() && !self.isPrinting();
    });
    // END: Slicing

    // Helpers for drawing walls and floor
    //
    self.createText = function (font, text, width, depth, parentObj) {
        var textGeometry = new THREE.TextGeometry(text, {
            font: font,
            size: 10,
            height: 0.1,
            material: 0, extrudeMaterial: 1
        });
        var materialFront = new THREE.MeshBasicMaterial({ color: 0x048e06 });
        var materialSide = new THREE.MeshBasicMaterial({ color: 0x8A8A8A });
        var materialArray = [materialFront, materialSide];
        var textMaterial = new THREE.MeshFaceMaterial(materialArray);

        var mesh = new THREE.Mesh(textGeometry, textMaterial);
        textGeometry.computeBoundingBox();
        var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
        var textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;
        switch (text) {
            case "Front":
                mesh.position.set(-textWidth / 2, -depth / 2 - textHeight - 4, 1.0);
                break;
            case "Back":
                mesh.position.set(textWidth / 2, depth / 2 + textHeight + 4, 1.0);
                mesh.rotation.set(0, 0, Math.PI);
                break;
            case "Left":
                mesh.position.set(-width / 2 - textHeight - 4, textWidth / 2, 1.0);
                mesh.rotation.set(0, 0, -Math.PI / 2);
                break;
            case "Right":
                mesh.position.set(width / 2 + textHeight, -textWidth / 2, 1.0);
                mesh.rotation.set(0, 0, Math.PI / 2);
                break;
        }
        parentObj.add(mesh);
    };

    self.drawBedFloor = function (width, depth, segments) {
        for (var i = self.floor.children.length - 1; i >= 0; i--) {
            var obj = self.floor.children[i];
            self.floor.remove(obj);
        }

        segments = segments || 20;
        var geometry = new THREE.PlaneGeometry(width, depth, segments, segments);
        var materialEven = new THREE.MeshBasicMaterial({ color: 0xccccfc });
        var materialOdd = new THREE.MeshBasicMaterial({ color: 0x444464 });
        var materials = [materialEven, materialOdd];
        for (var x = 0; x < segments; x++) {
            for (var y = 0; y < segments; y++) {
                var i = x * segments + y;
                var j = 2 * i;
                geometry.faces[j].materialIndex = geometry.faces[j + 1].materialIndex = (x + y) % 2;
            }
        }
        var mesh = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));
        mesh.receiveShadow = true;
        self.floor.add(mesh);

        //Add text to indicate front/back of print bed
        var loader = new THREE.FontLoader();
        loader.load(PLUGIN_BASEURL + "slicer/static/js/optimer_bold.typeface.json", function (font) {
            self.createText(font, "Front", width, depth, self.floor);
            self.createText(font, "Back", width, depth, self.floor);
            self.createText(font, "Left", width, depth, self.floor);
            self.createText(font, "Right", width, depth, self.floor);
            self.stlViewPort.render();
        });
    };

    self.drawWalls = function (width, depth, height) {
        for (var i = self.walls.children.length - 1; i >= 0; i--) {
            var obj = self.walls.children[i];
            self.walls.remove(obj);
        }

        var wall1 = self.rectShape(width, height, 0x8888fc);
        wall1.rotation.x = Math.PI / 2;
        wall1.position.set(0, depth / 2, height / 2);
        self.walls.add(wall1);

        var wall2 = self.rectShape(height, depth, 0x8888dc);
        wall2.rotation.y = Math.PI / 2;
        wall2.position.set(-width / 2, 0, height / 2);
        self.walls.add(wall2);

        var wall3 = self.rectShape(width, height, 0x8888fc);
        wall3.rotation.x = -Math.PI / 2;
        wall3.position.set(0, -depth / 2, height / 2);
        self.walls.add(wall3);

        var wall4 = self.rectShape(height, depth, 0x8888dc);
        wall4.rotation.y = -Math.PI / 2;
        wall4.position.set(width / 2, 0, height / 2);
        self.walls.add(wall4);
    };

    self.rectShape = function (rectLength, rectWidth, color) {
        var rectShape = new THREE.Shape();
        rectShape.moveTo(-rectLength / 2, -rectWidth / 2);
        rectShape.lineTo(-rectLength / 2, rectWidth / 2);
        rectShape.lineTo(rectLength / 2, rectWidth / 2);
        rectShape.lineTo(rectLength / 2, -rectWidth / 2);
        rectShape.lineTo(-rectLength / 2, -rectWidth / 2);
        var rectGeom = new THREE.ShapeGeometry(rectShape);
        return new THREE.Mesh(rectGeom, new THREE.MeshBasicMaterial({ color: color }));
    };
    // END: Helpers for drawing walls and floor

    self.resetSlicingViewModel = function () {
        self.slicingViewModel.target = undefined;
        self.slicingViewModel.file(undefined);
        self.slicingViewModel.destinationFilename(undefined);
    };

    self.setSlicingViewModel = function (target, filename) {
        if (!self.slicingViewModel.destinationFilename()) {
            // A model is added to an empty bed
            self.slicingViewModel.target = target;
            self.slicingViewModel.file(filename);
            self.slicingViewModel.destinationFilename(self.computeDestinationFilename(filename));
        }
    };

    // Returns the destination filename based on which models are loaded.
    // The destination filename is without the final .gco on it because
    // that will depend on the slicer.
    self.computeDestinationFilename = function (inputFilename) {
        // TODO: For now, just use the first model's name.
        var destinationFilename = inputFilename.substr(0, inputFilename.lastIndexOf("."));
        if (destinationFilename.lastIndexOf("/") != 0) {
            destinationFilename = destinationFilename.substr(destinationFilename.lastIndexOf("/") + 1);
        }
        return destinationFilename;
    };

    self.tempSTLFilename = function () {
        var pos = self.slicingViewModel.file().lastIndexOf(".");
        return [self.slicingViewModel.file().slice(0, pos), ".tmp." + +new Date(), self.slicingViewModel.file().slice(pos)].join('');
    };

    self.init();
}

// view model class, parameters for constructor, container to bind to
OCTOPRINT_VIEWMODELS.push([SlicerViewModel,

// e.g. loginStateViewModel, settingsViewModel, ...
["slicingViewModel", "overridesViewModel", "printerStateViewModel", "printerProfilesViewModel"],

// e.g. #settings_plugin_slicer, #tab_plugin_slicer, ...
["#slicer"]]);

}(THREE));
//# sourceMappingURL=octoprint_slicer.min.js.map
