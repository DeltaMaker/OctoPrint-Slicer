(function (three) {
'use strict';

/**
 * @author arodic / https://github.com/arodic
 */

function DefaultHandles() {

    var GizmoMaterial = function GizmoMaterial(parameters) {

        three.MeshBasicMaterial.call(this);

        this.depthTest = false;
        this.depthWrite = false;
        this.side = three.FrontSide;
        this.transparent = true;

        this.setValues(parameters);

        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;

        this.highlight = function (highlighted) {

            if (highlighted) {

                this.color.setRGB(1, 1, 0);
                this.opacity = 1;
            } else {

                this.color.copy(this.oldColor);
                this.opacity = this.oldOpacity;
            }
        };
    };

    GizmoMaterial.prototype = Object.create(three.MeshBasicMaterial.prototype);
    GizmoMaterial.prototype.constructor = GizmoMaterial;

    var GizmoLineMaterial = function GizmoLineMaterial(parameters) {

        three.LineBasicMaterial.call(this);

        this.depthTest = false;
        this.depthWrite = false;
        this.transparent = true;
        this.linewidth = 1;

        this.setValues(parameters);

        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;

        this.highlight = function (highlighted) {

            if (highlighted) {

                this.color.setRGB(1, 1, 0);
                this.opacity = 1;
            } else {

                this.color.copy(this.oldColor);
                this.opacity = this.oldOpacity;
            }
        };
    };

    GizmoLineMaterial.prototype = Object.create(three.LineBasicMaterial.prototype);
    GizmoLineMaterial.prototype.constructor = GizmoLineMaterial;

    var invisibleMaterial = new GizmoMaterial({ visible: false, transparent: false });

    var gizmoFromMap = function gizmoFromMap(gizmoMap) {

        var gizmo = new three.Object3D();

        for (var name in gizmoMap) {

            for (var i = gizmoMap[name].length; i--;) {

                var object = gizmoMap[name][i][0];
                var position = gizmoMap[name][i][1];
                var rotation = gizmoMap[name][i][2];

                object.name = name;

                if (position) object.position.set(position[0], position[1], position[2]);
                if (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);

                gizmo.add(object);
            }
        }

        return gizmo;
    };

    this.translateHandles = function () {
        var arrowGeometry = new three.Geometry();
        var mesh = new three.Mesh(new three.CylinderGeometry(0, 0.05, 0.2, 12, 1, false));
        mesh.position.y = 0.5;
        mesh.updateMatrix();

        arrowGeometry.merge(mesh.geometry, mesh.matrix);

        var lineXGeometry = new three.BufferGeometry();
        lineXGeometry.addAttribute('position', new three.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));

        var lineYGeometry = new three.BufferGeometry();
        lineYGeometry.addAttribute('position', new three.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

        var lineZGeometry = new three.BufferGeometry();
        lineZGeometry.addAttribute('position', new three.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

        return gizmoFromMap({
            X: [[new three.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new three.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))], [new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

            Y: [[new three.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new three.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))], [new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0, 0.6, 0]]],

            Z: [[new three.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new three.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))], [new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

            XYZ: [[new three.Mesh(new three.OctahedronGeometry(0.1, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })), [0, 0, 0], [0, 0, 0]], [new three.Mesh(new three.OctahedronGeometry(0.2, 0), invisibleMaterial)]],

            XY: [[new three.Mesh(new three.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.15, 0.15, 0]], [new three.Mesh(new three.PlaneBufferGeometry(0.4, 0.4), invisibleMaterial), [0.2, 0.2, 0]]],

            YZ: [[new three.Mesh(new three.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.15, 0.15], [0, Math.PI / 2, 0]], [new three.Mesh(new three.PlaneBufferGeometry(0.4, 0.4), invisibleMaterial), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],

            XZ: [[new three.Mesh(new three.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]], [new three.Mesh(new three.PlaneBufferGeometry(0.4, 0.4), invisibleMaterial), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]

        });
    };

    this.rotateHandles = function () {

        var CircleGeometry = function CircleGeometry(radius, facing, arc) {

            var geometry = new three.BufferGeometry();
            var vertices = [];
            arc = arc ? arc : 1;

            for (var i = 0; i <= 64 * arc; ++i) {

                if (facing === 'x') vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);
                if (facing === 'y') vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0, Math.sin(i / 32 * Math.PI) * radius);
                if (facing === 'z') vertices.push(Math.sin(i / 32 * Math.PI) * radius, Math.cos(i / 32 * Math.PI) * radius, 0);
            }

            geometry.addAttribute('position', new three.Float32BufferAttribute(vertices, 3));
            return geometry;
        };

        return gizmoFromMap({
            X: [[new three.Line(new CircleGeometry(1, 'x', 0.5), new GizmoLineMaterial({ color: 0xff0000 }))], [new three.Mesh(new three.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), invisibleMaterial), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],

            Y: [[new three.Line(new CircleGeometry(1, 'y', 0.5), new GizmoLineMaterial({ color: 0x00ff00 }))], [new three.Mesh(new three.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), invisibleMaterial), [0, 0, 0], [Math.PI / 2, 0, 0]]],

            Z: [[new three.Line(new CircleGeometry(1, 'z', 0.5), new GizmoLineMaterial({ color: 0x0000ff }))], [new three.Mesh(new three.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), invisibleMaterial), [0, 0, 0], [0, 0, -Math.PI / 2]]],

            E: [[new three.Line(new CircleGeometry(1.25, 'z', 1), new GizmoLineMaterial({ color: 0xcccc00 }))], [new three.Mesh(new three.TorusBufferGeometry(1.25, 0.12, 2, 24), invisibleMaterial)]],

            XYZE: [[new three.Line(new CircleGeometry(1, 'z', 1), new GizmoLineMaterial({ color: 0x787878 }))], [new three.Mesh()] // TODO
            ]
        });
    };

    this.scaleHandles = function () {
        var arrowGeometry = new three.Geometry();
        var mesh = new three.Mesh(new three.BoxGeometry(0.125, 0.125, 0.125));
        mesh.position.y = 0.5;
        mesh.updateMatrix();

        arrowGeometry.merge(mesh.geometry, mesh.matrix);

        var lineXGeometry = new three.BufferGeometry();
        lineXGeometry.addAttribute('position', new three.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));

        var lineYGeometry = new three.BufferGeometry();
        lineYGeometry.addAttribute('position', new three.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

        var lineZGeometry = new three.BufferGeometry();
        lineZGeometry.addAttribute('position', new three.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

        return gizmoFromMap({
            X: [[new three.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new three.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))], [new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

            Y: [[new three.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new three.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))], [new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0, 0.6, 0]]],

            Z: [[new three.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new three.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))], [new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), invisibleMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

            XYZ: [[new three.Mesh(new three.BoxBufferGeometry(0.125, 0.125, 0.125), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))], [new three.Mesh(new three.BoxBufferGeometry(0.4, 0.4, 0.4), invisibleMaterial)]]
        });
    };
}

function TransformGizmo(handles) {

    this.handles = handles;

    this.init = function () {

        three.Object3D.call(this);

        this.add(this.handles);

        this.planes = new three.Object3D();
        this.add(this.planes);

        //// PLANES

        var planeGeometry = new three.PlaneBufferGeometry(50, 50, 2, 2);
        var planeMaterial = new three.MeshBasicMaterial({ visible: false, side: three.DoubleSide });

        var planes = {
            "XY": new three.Mesh(planeGeometry, planeMaterial),
            "YZ": new three.Mesh(planeGeometry, planeMaterial),
            "XZ": new three.Mesh(planeGeometry, planeMaterial),
            "XYZE": new three.Mesh(planeGeometry, planeMaterial)
        };

        this.activePlane = planes["XYZE"];

        planes["YZ"].rotation.set(0, Math.PI / 2, 0);
        planes["XZ"].rotation.set(-Math.PI / 2, 0, 0);

        for (var i in planes) {

            planes[i].name = i;
            this.planes.add(planes[i]);
            this.planes[i] = planes[i];
        }

        // reset Transformations

        this.traverse(function (child) {

            if (child instanceof three.Mesh) {

                child.updateMatrix();

                var tempGeometry = child.geometry.clone();
                tempGeometry.applyMatrix(child.matrix);
                child.geometry = tempGeometry;

                child.position.set(0, 0, 0);
                child.rotation.set(0, 0, 0);
                child.scale.set(1, 1, 1);
            }
        });
    };

    this.setHandles = function (handles) {

        this.remove(this.handles);
        this.handles = handles;
        if (this.handles !== null) {
            this.add(this.handles);
        }
    };

    this.highlight = function (axis) {

        this.traverse(function (child) {

            if (child.material && child.material.highlight) {

                if (child.name === axis) {

                    child.material.highlight(true);
                } else {

                    child.material.highlight(false);
                }
            }
        });
    };
}

TransformGizmo.prototype = Object.create(three.Object3D.prototype);
TransformGizmo.prototype.constructor = TransformGizmo;

TransformGizmo.prototype.update = function (rotation, eye) {

    var vec1 = new three.Vector3(0, 0, 0);
    var vec2 = new three.Vector3(0, 1, 0);
    var lookAtMatrix = new three.Matrix4();

    this.traverse(function (child) {

        if (child.name.search("E") !== -1) {

            child.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));
        } else if (child.name.search("X") !== -1 || child.name.search("Y") !== -1 || child.name.search("Z") !== -1) {

            child.quaternion.setFromEuler(rotation);
        }
    });
};

function TransformGizmoTranslate(handles) {

    TransformGizmo.call(this, handles);

    this.setActivePlane = function (axis, eye) {

        var tempMatrix = new three.Matrix4();
        eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

        if (axis === "X") {

            this.activePlane = this.planes["XY"];

            if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
        }

        if (axis === "Y") {

            this.activePlane = this.planes["XY"];

            if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
        }

        if (axis === "Z") {

            this.activePlane = this.planes["XZ"];

            if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
        }

        if (axis === "XYZ") this.activePlane = this.planes["XYZE"];

        if (axis === "XY") this.activePlane = this.planes["XY"];

        if (axis === "YZ") this.activePlane = this.planes["YZ"];

        if (axis === "XZ") this.activePlane = this.planes["XZ"];
    };

    this.init();
}

TransformGizmoTranslate.prototype = Object.create(TransformGizmo.prototype);
TransformGizmoTranslate.prototype.constructor = TransformGizmoTranslate;

function TransformGizmoRotate(handles) {

    TransformGizmo.call(this, handles);

    this.setActivePlane = function (axis) {

        if (axis === "E") this.activePlane = this.planes["XYZE"];

        if (axis === "X") this.activePlane = this.planes["YZ"];

        if (axis === "Y") this.activePlane = this.planes["XZ"];

        if (axis === "Z") this.activePlane = this.planes["XY"];
    };

    this.update = function (rotation, eye2) {

        TransformGizmo.prototype.update.apply(this, arguments);

        var group = {

            handles: this["handles"]

        };

        var tempMatrix = new three.Matrix4();
        var worldRotation = new three.Euler(0, 0, 1);
        var tempQuaternion = new three.Quaternion();
        var unitX = new three.Vector3(1, 0, 0);
        var unitY = new three.Vector3(0, 1, 0);
        var unitZ = new three.Vector3(0, 0, 1);
        var quaternionX = new three.Quaternion();
        var quaternionY = new three.Quaternion();
        var quaternionZ = new three.Quaternion();
        var eye = eye2.clone();

        worldRotation.copy(this.planes["XY"].rotation);
        tempQuaternion.setFromEuler(worldRotation);

        tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);
        eye.applyMatrix4(tempMatrix);

        this.traverse(function (child) {

            tempQuaternion.setFromEuler(worldRotation);

            if (child.name === "X") {

                quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                child.quaternion.copy(tempQuaternion);
            }

            if (child.name === "Y") {

                quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
                child.quaternion.copy(tempQuaternion);
            }

            if (child.name === "Z") {

                quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
                child.quaternion.copy(tempQuaternion);
            }
        });
    };

    this.init();
}

TransformGizmoRotate.prototype = Object.create(TransformGizmo.prototype);
TransformGizmoRotate.prototype.constructor = TransformGizmoRotate;

function TransformGizmoScale(handles) {

    TransformGizmo.call(this, handles);

    this.setActivePlane = function (axis, eye) {

        var tempMatrix = new three.Matrix4();
        eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

        if (axis === "X") {

            this.activePlane = this.planes["XY"];
            if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
        }

        if (axis === "Y") {

            this.activePlane = this.planes["XY"];
            if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
        }

        if (axis === "Z") {

            this.activePlane = this.planes["XZ"];
            if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
        }

        if (axis === "XYZ") this.activePlane = this.planes["XYZE"];
    };

    this.init();
}

TransformGizmoScale.prototype = Object.create(TransformGizmo.prototype);
TransformGizmoScale.prototype.constructor = TransformGizmoScale;

function TransformControls(camera, domElement) {

    // TODO: Make non-uniform scale and rotate play nice in hierarchies
    // TODO: ADD RXYZ contol

    three.Object3D.call(this);

    domElement = domElement !== undefined ? domElement : document;

    this.defaultHandles = new DefaultHandles();

    this.object = undefined;
    this.visible = false;
    this.translationSnap = null;
    this.rotationSnap = null;
    this.space = "world";
    this.size = 1;
    this.axis = null;
    this.dragObject = false;

    var scope = this;

    var _mode = "translate";
    var _dragging = false;
    var _plane = "XY";
    var _gizmo = {
        "translate": new TransformGizmoTranslate(scope.defaultHandles.translateHandles()),
        "rotate": new TransformGizmoRotate(scope.defaultHandles.rotateHandles()),
        "scale": new TransformGizmoScale(scope.defaultHandles.scaleHandles())
    };

    for (var type in _gizmo) {

        var gizmoObj = _gizmo[type];

        gizmoObj.visible = type === _mode;
        this.add(gizmoObj);
    }

    var changeEvent = { type: "change" };
    var mouseDownEvent = { type: "mouseDown" };
    var mouseUpEvent = { type: "mouseUp", mode: _mode };
    var objectChangeEvent = { type: "objectChange" };

    var ray = new three.Raycaster();
    ray.linePrecision = 0.01;
    var pointerVector = new three.Vector2();

    var point = new three.Vector3();
    var offset = new three.Vector3();

    var rotation = new three.Vector3();
    var offsetRotation = new three.Vector3();
    var scale = 1;

    var lookAtMatrix = new three.Matrix4();
    var eye = new three.Vector3();

    var tempMatrix = new three.Matrix4();
    var tempVector = new three.Vector3();
    var tempQuaternion = new three.Quaternion();
    var unitX = new three.Vector3(1, 0, 0);
    var unitY = new three.Vector3(0, 1, 0);
    var unitZ = new three.Vector3(0, 0, 1);

    var quaternionXYZ = new three.Quaternion();
    var quaternionX = new three.Quaternion();
    var quaternionY = new three.Quaternion();
    var quaternionZ = new three.Quaternion();
    var quaternionE = new three.Quaternion();

    var oldPosition = new three.Vector3();
    var oldScale = new three.Vector3();
    var oldRotationMatrix = new three.Matrix4();

    var parentRotationMatrix = new three.Matrix4();
    var parentScale = new three.Vector3();

    var worldPosition = new three.Vector3();
    var worldRotation = new three.Euler();
    var worldRotationMatrix = new three.Matrix4();
    var camPosition = new three.Vector3();
    var camRotation = new three.Euler();

    domElement.addEventListener("mousedown", onPointerDown, false);
    domElement.addEventListener("touchstart", onPointerDown, false);

    domElement.addEventListener("mousemove", onPointerHover, false);
    domElement.addEventListener("touchmove", onPointerHover, false);

    domElement.addEventListener("mousemove", onPointerMove, false);
    domElement.addEventListener("touchmove", onPointerMove, false);

    domElement.addEventListener("mouseup", onPointerUp, false);
    domElement.addEventListener("mouseout", onPointerUp, false);
    domElement.addEventListener("touchend", onPointerUp, false);
    domElement.addEventListener("touchcancel", onPointerUp, false);
    domElement.addEventListener("touchleave", onPointerUp, false);

    this.dispose = function () {

        domElement.removeEventListener("mousedown", onPointerDown);
        domElement.removeEventListener("touchstart", onPointerDown);

        domElement.removeEventListener("mousemove", onPointerHover);
        domElement.removeEventListener("touchmove", onPointerHover);

        domElement.removeEventListener("mousemove", onPointerMove);
        domElement.removeEventListener("touchmove", onPointerMove);

        domElement.removeEventListener("mouseup", onPointerUp);
        domElement.removeEventListener("mouseout", onPointerUp);
        domElement.removeEventListener("touchend", onPointerUp);
        domElement.removeEventListener("touchcancel", onPointerUp);
        domElement.removeEventListener("touchleave", onPointerUp);
    };

    this.attach = function (object) {

        this.object = object;
        this.visible = true;
        this.update();
    };

    this.detach = function () {

        this.object = undefined;
        this.visible = false;
        this.axis = null;
    };

    this.getMode = function () {

        return _mode;
    };

    this.setMode = function (mode) {

        _mode = mode ? mode : _mode;

        if (_mode === "scale") scope.space = "local";

        for (var type in _gizmo) {
            _gizmo[type].visible = type === _mode;
        }this.update();
        scope.dispatchEvent(changeEvent);
    };

    this.setTranslationSnap = function (translationSnap) {

        scope.translationSnap = translationSnap;
    };

    this.setRotationSnap = function (rotationSnap) {

        scope.rotationSnap = rotationSnap;
    };

    this.setSize = function (size) {

        scope.size = size;
        this.update();
        scope.dispatchEvent(changeEvent);
    };

    this.setSpace = function (space) {

        scope.space = space;
        this.update();
        scope.dispatchEvent(changeEvent);
    };

    this.setHandles = function (mode, handles) {

        _gizmo[mode].setHandles(handles);
        scope.update();
        scope.dispatchEvent(changeEvent);
    };

    this.update = function () {

        if (scope.object === undefined) return;

        scope.object.updateMatrixWorld();
        worldPosition.setFromMatrixPosition(scope.object.matrixWorld);
        worldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));

        camera.updateMatrixWorld();
        camPosition.setFromMatrixPosition(camera.matrixWorld);
        camRotation.setFromRotationMatrix(tempMatrix.extractRotation(camera.matrixWorld));

        scale = worldPosition.distanceTo(camPosition) / 6 * scope.size;
        this.position.copy(worldPosition);
        this.scale.set(scale, scale, scale);

        if (camera instanceof three.PerspectiveCamera) {

            eye.copy(camPosition).sub(worldPosition).normalize();
        } else if (camera instanceof three.OrthographicCamera) {

            eye.copy(camPosition).normalize();
        }

        if (scope.space === "local") {

            _gizmo[_mode].update(worldRotation, eye);
        } else if (scope.space === "world") {

            _gizmo[_mode].update(new three.Euler(), eye);
        }

        _gizmo[_mode].highlight(scope.axis);
    };

    function onPointerHover(event) {

        if (scope.object === undefined || _dragging === true || _gizmo[_mode].handles === null || event.button !== undefined && event.button !== 0) return;

        var pointer = event.changedTouches ? event.changedTouches[0] : event;

        var intersect = intersectObjects(pointer, _gizmo[_mode].handles.children);

        var axis = null;

        if (intersect) {

            axis = intersect.object.name;

            event.preventDefault();
        }

        if (scope.axis !== axis) {

            scope.axis = axis;
            scope.update();
            scope.dispatchEvent(changeEvent);
        }
    }

    function onPointerDown(event) {

        if (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;

        var pointer = event.changedTouches ? event.changedTouches[0] : event;

        if (pointer.button === 0 || pointer.button === undefined) {

            if (_gizmo[_mode].handles !== null) {

                var intersect = intersectObjects(pointer, _gizmo[_mode].handles.children);

                if (!intersect) return;

                event.preventDefault();
                event.stopPropagation();

                scope.dispatchEvent(mouseDownEvent);

                scope.axis = intersect.object.name;
            }

            if (!scope.axis) return;

            scope.update();

            eye.copy(camPosition).sub(worldPosition).normalize();

            _gizmo[_mode].setActivePlane(scope.axis, eye);

            var planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);

            if (planeIntersect) {

                oldPosition.copy(scope.object.position);
                oldScale.copy(scope.object.scale);

                oldRotationMatrix.extractRotation(scope.object.matrix);
                worldRotationMatrix.extractRotation(scope.object.matrixWorld);

                parentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);
                parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));

                offset.copy(planeIntersect.point);
            }
        }

        _dragging = true;
    }

    function onPointerMove(event) {

        if (scope.object === undefined || scope.axis === null || _dragging === false || event.button !== undefined && event.button !== 0) return;

        var pointer = event.changedTouches ? event.changedTouches[0] : event;

        var planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);

        if (planeIntersect === false) return;

        event.preventDefault();
        event.stopPropagation();

        point.copy(planeIntersect.point);

        if (_mode === "translate") {

            point.sub(offset);
            point.multiply(parentScale);

            if (scope.space === "local") {

                point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

                if (scope.axis.search("X") === -1) point.x = 0;
                if (scope.axis.search("Y") === -1) point.y = 0;
                if (scope.axis.search("Z") === -1) point.z = 0;

                point.applyMatrix4(oldRotationMatrix);

                scope.object.position.copy(oldPosition);
                scope.object.position.add(point);
            }

            if (scope.space === "world" || scope.axis.search("XYZ") !== -1) {

                if (scope.axis.search("X") === -1) point.x = 0;
                if (scope.axis.search("Y") === -1) point.y = 0;
                if (scope.axis.search("Z") === -1) point.z = 0;

                point.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));

                scope.object.position.copy(oldPosition);
                scope.object.position.add(point);
            }

            if (scope.translationSnap !== null) {

                if (scope.space === "local") {

                    scope.object.position.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
                }

                if (scope.axis.search("X") !== -1) scope.object.position.x = Math.round(scope.object.position.x / scope.translationSnap) * scope.translationSnap;
                if (scope.axis.search("Y") !== -1) scope.object.position.y = Math.round(scope.object.position.y / scope.translationSnap) * scope.translationSnap;
                if (scope.axis.search("Z") !== -1) scope.object.position.z = Math.round(scope.object.position.z / scope.translationSnap) * scope.translationSnap;

                if (scope.space === "local") {

                    scope.object.position.applyMatrix4(worldRotationMatrix);
                }
            }
        } else if (_mode === "scale") {

            point.sub(offset);
            point.multiply(parentScale);

            if (scope.space === "local") {

                if (scope.axis === "XYZ") {

                    scale = 1 + point.y / Math.max(oldScale.x, oldScale.y, oldScale.z);

                    scope.object.scale.x = oldScale.x * scale;
                    scope.object.scale.y = oldScale.y * scale;
                    scope.object.scale.z = oldScale.z * scale;
                } else {

                    point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

                    if (scope.axis === "X") scope.object.scale.x = oldScale.x * (1 + point.x / oldScale.x);
                    if (scope.axis === "Y") scope.object.scale.y = oldScale.y * (1 + point.y / oldScale.y);
                    if (scope.axis === "Z") scope.object.scale.z = oldScale.z * (1 + point.z / oldScale.z);
                }
            }
        } else if (_mode === "rotate") {

            point.sub(worldPosition);
            point.multiply(parentScale);
            tempVector.copy(offset).sub(worldPosition);
            tempVector.multiply(parentScale);

            if (scope.axis === "E") {

                point.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
                tempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));

                rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

                tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

                quaternionE.setFromAxisAngle(eye, rotation.z - offsetRotation.z);
                quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

                scope.object.quaternion.copy(tempQuaternion);
            } else if (scope.axis === "XYZE") {

                quaternionE.setFromEuler(point.clone().cross(tempVector).normalize()); // rotation axis

                tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));
                quaternionX.setFromAxisAngle(quaternionE, -point.clone().angleTo(tempVector));
                quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

                scope.object.quaternion.copy(tempQuaternion);
            } else if (scope.space === "local") {

                point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

                tempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

                rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

                quaternionXYZ.setFromRotationMatrix(oldRotationMatrix);

                if (scope.rotationSnap !== null) {

                    quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
                    quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
                    quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
                } else {

                    quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
                    quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
                    quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
                }

                if (scope.axis === "X") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);
                if (scope.axis === "Y") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);
                if (scope.axis === "Z") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);

                scope.object.quaternion.copy(quaternionXYZ);
            } else if (scope.space === "world") {

                rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

                tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

                if (scope.rotationSnap !== null) {

                    quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
                    quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
                    quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
                } else {

                    quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
                    quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
                    quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
                }

                quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

                if (scope.axis === "X") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                if (scope.axis === "Y") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
                if (scope.axis === "Z") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);

                tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

                scope.object.quaternion.copy(tempQuaternion);
            }
        }

        scope.update();
        scope.dispatchEvent(changeEvent);
        scope.dispatchEvent(objectChangeEvent);
    }

    function onPointerUp(event) {

        event.preventDefault(); // Prevent MouseEvent on mobile

        if (event.button !== undefined && event.button !== 0) return;

        if (_dragging && scope.axis !== null) {

            mouseUpEvent.mode = _mode;
            scope.dispatchEvent(mouseUpEvent);
        }

        _dragging = false;

        if ('TouchEvent' in window && event instanceof TouchEvent) {

            // Force "rollover"

            scope.axis = null;
            scope.update();
            scope.dispatchEvent(changeEvent);
        } else {

            onPointerHover(event);
        }
    }

    function intersectObjects(pointer, objects) {

        var rect = domElement.getBoundingClientRect();
        var x = (pointer.clientX - rect.left) / rect.width;
        var y = (pointer.clientY - rect.top) / rect.height;

        pointerVector.set(x * 2 - 1, -(y * 2) + 1);
        ray.setFromCamera(pointerVector, camera);

        var intersections = ray.intersectObjects(objects, true);
        return intersections[0] ? intersections[0] : false;
    }
}

TransformControls.prototype = Object.create(three.Object3D.prototype);
TransformControls.prototype.constructor = TransformControls;

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finger swipe

function OrbitControls(object, domElement) {

    this.object = object;

    this.domElement = domElement !== undefined ? domElement : document;

    // Set to false to disable this control
    this.enabled = true;

    // "target" sets the location of focus, where the object orbits around
    this.target = new three.Vector3();

    // How far you can dolly in and out ( PerspectiveCamera only )
    this.minDistance = 0;
    this.maxDistance = Infinity;

    // How far you can zoom in and out ( OrthographicCamera only )
    this.minZoom = 0;
    this.maxZoom = Infinity;

    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    this.minPolarAngle = 0; // radians
    this.maxPolarAngle = Math.PI; // radians

    // How far you can orbit horizontally, upper and lower limits.
    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
    this.minAzimuthAngle = -Infinity; // radians
    this.maxAzimuthAngle = Infinity; // radians

    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop
    this.enableDamping = false;
    this.dampingFactor = 0.25;

    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming
    this.enableZoom = true;
    this.zoomSpeed = 1.0;

    // Set to false to disable rotating
    this.enableRotate = true;
    this.rotateSpeed = 1.0;

    // Set to false to disable panning
    this.enablePan = true;
    this.keyPanSpeed = 7.0; // pixels moved per arrow key push

    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop
    this.autoRotate = false;
    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

    // Set to false to disable use of the keys
    this.enableKeys = true;

    // The four arrow keys
    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

    // Mouse buttons
    this.mouseButtons = { ORBIT: three.MOUSE.LEFT, ZOOM: three.MOUSE.MIDDLE, PAN: three.MOUSE.RIGHT };

    // for reset
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;

    //
    // public methods
    //

    this.getPolarAngle = function () {

        return spherical.phi;
    };

    this.getAzimuthalAngle = function () {

        return spherical.theta;
    };

    this.saveState = function () {

        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
    };

    this.reset = function () {

        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;

        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(changeEvent);

        scope.update();

        state = STATE.NONE;
    };

    // this method is exposed, but perhaps it would be better if we can make it private...
    this.update = function () {

        var offset = new three.Vector3();

        // so camera.up is the orbit axis
        var quat = new three.Quaternion().setFromUnitVectors(object.up, new three.Vector3(0, 1, 0));
        var quatInverse = quat.clone().inverse();

        var lastPosition = new three.Vector3();
        var lastQuaternion = new three.Quaternion();

        return function update() {

            var position = scope.object.position;

            offset.copy(position).sub(scope.target);

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);

            // angle from z-axis around y-axis
            spherical.setFromVector3(offset);

            if (scope.autoRotate && state === STATE.NONE) {

                rotateLeft(getAutoRotationAngle());
            }

            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;

            // restrict theta to be between desired limits
            spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));

            // restrict phi to be between desired limits
            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));

            spherical.makeSafe();

            spherical.radius *= scale;

            // restrict radius to be between desired limits
            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

            // move target to panned location
            scope.target.add(panOffset);

            offset.setFromSpherical(spherical);

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);

            position.copy(scope.target).add(offset);

            scope.object.lookAt(scope.target);

            if (scope.enableDamping === true) {

                sphericalDelta.theta *= 1 - scope.dampingFactor;
                sphericalDelta.phi *= 1 - scope.dampingFactor;
            } else {

                sphericalDelta.set(0, 0, 0);
            }

            scale = 1;
            panOffset.set(0, 0, 0);

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {

                scope.dispatchEvent(changeEvent);

                lastPosition.copy(scope.object.position);
                lastQuaternion.copy(scope.object.quaternion);
                zoomChanged = false;

                return true;
            }

            return false;
        };
    }();

    this.dispose = function () {

        scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
        scope.domElement.removeEventListener('mousedown', onMouseDown, false);
        scope.domElement.removeEventListener('wheel', onMouseWheel, false);

        scope.domElement.removeEventListener('touchstart', onTouchStart, false);
        scope.domElement.removeEventListener('touchend', onTouchEnd, false);
        scope.domElement.removeEventListener('touchmove', onTouchMove, false);

        document.removeEventListener('mousemove', onMouseMove, false);
        document.removeEventListener('mouseup', onMouseUp, false);

        window.removeEventListener('keydown', onKeyDown, false);

        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
    };

    //
    // internals
    //

    var scope = this;

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

    var state = STATE.NONE;

    var EPS = 0.000001;

    // current position in spherical coordinates
    var spherical = new three.Spherical();
    var sphericalDelta = new three.Spherical();

    var scale = 1;
    var panOffset = new three.Vector3();
    var zoomChanged = false;

    var rotateStart = new three.Vector2();
    var rotateEnd = new three.Vector2();
    var rotateDelta = new three.Vector2();

    var panStart = new three.Vector2();
    var panEnd = new three.Vector2();
    var panDelta = new three.Vector2();

    var dollyStart = new three.Vector2();
    var dollyEnd = new three.Vector2();
    var dollyDelta = new three.Vector2();

    function getAutoRotationAngle() {

        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }

    function getZoomScale() {

        return Math.pow(0.95, scope.zoomSpeed);
    }

    function rotateLeft(angle) {

        sphericalDelta.theta -= angle;
    }

    function rotateUp(angle) {

        sphericalDelta.phi -= angle;
    }

    var panLeft = function () {

        var v = new three.Vector3();

        return function panLeft(distance, objectMatrix) {

            v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
            v.multiplyScalar(-distance);

            panOffset.add(v);
        };
    }();

    var panUp = function () {

        var v = new three.Vector3();

        return function panUp(distance, objectMatrix) {

            v.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix
            v.multiplyScalar(distance);

            panOffset.add(v);
        };
    }();

    // deltaX and deltaY are in pixels; right and down are positive
    var pan = function () {

        var offset = new three.Vector3();

        return function pan(deltaX, deltaY) {

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if (scope.object instanceof three.PerspectiveCamera) {

                // perspective
                var position = scope.object.position;
                offset.copy(position).sub(scope.target);
                var targetDistance = offset.length();

                // half of the fov is center to top of screen
                targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

                // we actually don't use screenWidth, since perspective camera is fixed to screen height
                panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
                panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
            } else if (scope.object instanceof three.OrthographicCamera) {

                // orthographic
                panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
                panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
            } else {

                // camera neither orthographic nor perspective
                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
                scope.enablePan = false;
            }
        };
    }();

    function dollyIn(dollyScale) {

        if (scope.object instanceof three.PerspectiveCamera) {

            scale /= dollyScale;
        } else if (scope.object instanceof three.OrthographicCamera) {

            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
        } else {

            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            scope.enableZoom = false;
        }
    }

    function dollyOut(dollyScale) {

        if (scope.object instanceof three.PerspectiveCamera) {

            scale *= dollyScale;
        } else if (scope.object instanceof three.OrthographicCamera) {

            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
        } else {

            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            scope.enableZoom = false;
        }
    }

    //
    // event callbacks - update the object state
    //

    function handleMouseDownRotate(event) {

        //console.log( 'handleMouseDownRotate' );

        rotateStart.set(event.clientX, event.clientY);
    }

    function handleMouseDownDolly(event) {

        //console.log( 'handleMouseDownDolly' );

        dollyStart.set(event.clientX, event.clientY);
    }

    function handleMouseDownPan(event) {

        //console.log( 'handleMouseDownPan' );

        panStart.set(event.clientX, event.clientY);
    }

    function handleMouseMoveRotate(event) {

        //console.log( 'handleMouseMoveRotate' );

        rotateEnd.set(event.clientX, event.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart);

        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

        // rotating across whole screen goes 360 degrees around
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

        // rotating up and down along whole screen attempts to go 360, but limited to 180
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

        rotateStart.copy(rotateEnd);

        scope.update();
    }

    function handleMouseMoveDolly(event) {

        //console.log( 'handleMouseMoveDolly' );

        dollyEnd.set(event.clientX, event.clientY);

        dollyDelta.subVectors(dollyEnd, dollyStart);

        if (dollyDelta.y > 0) {

            dollyIn(getZoomScale());
        } else if (dollyDelta.y < 0) {

            dollyOut(getZoomScale());
        }

        dollyStart.copy(dollyEnd);

        scope.update();
    }

    function handleMouseMovePan(event) {

        //console.log( 'handleMouseMovePan' );

        panEnd.set(event.clientX, event.clientY);

        panDelta.subVectors(panEnd, panStart);

        pan(panDelta.x, panDelta.y);

        panStart.copy(panEnd);

        scope.update();
    }

    function handleMouseUp(event) {

        // console.log( 'handleMouseUp' );

    }

    function handleMouseWheel(event) {

        // console.log( 'handleMouseWheel' );

        if (event.deltaY < 0) {

            dollyOut(getZoomScale());
        } else if (event.deltaY > 0) {

            dollyIn(getZoomScale());
        }

        scope.update();
    }

    function handleKeyDown(event) {

        //console.log( 'handleKeyDown' );

        switch (event.keyCode) {

            case scope.keys.UP:
                pan(0, scope.keyPanSpeed);
                scope.update();
                break;

            case scope.keys.BOTTOM:
                pan(0, -scope.keyPanSpeed);
                scope.update();
                break;

            case scope.keys.LEFT:
                pan(scope.keyPanSpeed, 0);
                scope.update();
                break;

            case scope.keys.RIGHT:
                pan(-scope.keyPanSpeed, 0);
                scope.update();
                break;

        }
    }

    function handleTouchStartRotate(event) {

        //console.log( 'handleTouchStartRotate' );

        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }

    function handleTouchStartDolly(event) {

        //console.log( 'handleTouchStartDolly' );

        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;

        var distance = Math.sqrt(dx * dx + dy * dy);

        dollyStart.set(0, distance);
    }

    function handleTouchStartPan(event) {

        //console.log( 'handleTouchStartPan' );

        panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }

    function handleTouchMoveRotate(event) {

        //console.log( 'handleTouchMoveRotate' );

        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        rotateDelta.subVectors(rotateEnd, rotateStart);

        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

        // rotating across whole screen goes 360 degrees around
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

        // rotating up and down along whole screen attempts to go 360, but limited to 180
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

        rotateStart.copy(rotateEnd);

        scope.update();
    }

    function handleTouchMoveDolly(event) {

        //console.log( 'handleTouchMoveDolly' );

        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;

        var distance = Math.sqrt(dx * dx + dy * dy);

        dollyEnd.set(0, distance);

        dollyDelta.subVectors(dollyEnd, dollyStart);

        if (dollyDelta.y > 0) {

            dollyOut(getZoomScale());
        } else if (dollyDelta.y < 0) {

            dollyIn(getZoomScale());
        }

        dollyStart.copy(dollyEnd);

        scope.update();
    }

    function handleTouchMovePan(event) {

        //console.log( 'handleTouchMovePan' );

        panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

        panDelta.subVectors(panEnd, panStart);

        pan(panDelta.x, panDelta.y);

        panStart.copy(panEnd);

        scope.update();
    }

    function handleTouchEnd(event) {}

    //console.log( 'handleTouchEnd' );

    //
    // event handlers - FSM: listen for events and reset state
    //

    function onMouseDown(event) {

        if (scope.enabled === false) return;

        event.preventDefault();

        if (event.button === scope.mouseButtons.ORBIT) {

            if (scope.enableRotate === false) return;

            handleMouseDownRotate(event);

            state = STATE.ROTATE;
        } else if (event.button === scope.mouseButtons.ZOOM) {

            if (scope.enableZoom === false) return;

            handleMouseDownDolly(event);

            state = STATE.DOLLY;
        } else if (event.button === scope.mouseButtons.PAN) {

            if (scope.enablePan === false) return;

            handleMouseDownPan(event);

            state = STATE.PAN;
        }

        if (state !== STATE.NONE) {

            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);

            scope.dispatchEvent(startEvent);
        }
    }

    function onMouseMove(event) {

        if (scope.enabled === false) return;

        event.preventDefault();

        if (state === STATE.ROTATE) {

            if (scope.enableRotate === false) return;

            handleMouseMoveRotate(event);
        } else if (state === STATE.DOLLY) {

            if (scope.enableZoom === false) return;

            handleMouseMoveDolly(event);
        } else if (state === STATE.PAN) {

            if (scope.enablePan === false) return;

            handleMouseMovePan(event);
        }
    }

    function onMouseUp(event) {

        if (scope.enabled === false) return;

        handleMouseUp(event);

        document.removeEventListener('mousemove', onMouseMove, false);
        document.removeEventListener('mouseup', onMouseUp, false);

        scope.dispatchEvent(endEvent);

        state = STATE.NONE;
    }

    function onMouseWheel(event) {

        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;

        event.preventDefault();
        event.stopPropagation();

        handleMouseWheel(event);

        scope.dispatchEvent(startEvent); // not sure why these are here...
        scope.dispatchEvent(endEvent);
    }

    function onKeyDown(event) {

        if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

        handleKeyDown(event);
    }

    function onTouchStart(event) {

        if (scope.enabled === false) return;

        switch (event.touches.length) {

            case 1:
                // one-fingered touch: rotate

                if (scope.enableRotate === false) return;

                handleTouchStartRotate(event);

                state = STATE.TOUCH_ROTATE;

                break;

            case 2:
                // two-fingered touch: dolly

                if (scope.enableZoom === false) return;

                handleTouchStartDolly(event);

                state = STATE.TOUCH_DOLLY;

                break;

            case 3:
                // three-fingered touch: pan

                if (scope.enablePan === false) return;

                handleTouchStartPan(event);

                state = STATE.TOUCH_PAN;

                break;

            default:

                state = STATE.NONE;

        }

        if (state !== STATE.NONE) {

            scope.dispatchEvent(startEvent);
        }
    }

    function onTouchMove(event) {

        if (scope.enabled === false) return;

        event.preventDefault();
        event.stopPropagation();

        switch (event.touches.length) {

            case 1:
                // one-fingered touch: rotate

                if (scope.enableRotate === false) return;
                if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

                handleTouchMoveRotate(event);

                break;

            case 2:
                // two-fingered touch: dolly

                if (scope.enableZoom === false) return;
                if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

                handleTouchMoveDolly(event);

                break;

            case 3:
                // three-fingered touch: pan

                if (scope.enablePan === false) return;
                if (state !== STATE.TOUCH_PAN) return; // is this needed?...

                handleTouchMovePan(event);

                break;

            default:

                state = STATE.NONE;

        }
    }

    function onTouchEnd(event) {

        if (scope.enabled === false) return;

        handleTouchEnd(event);

        scope.dispatchEvent(endEvent);

        state = STATE.NONE;
    }

    function onContextMenu(event) {

        event.preventDefault();
    }

    //

    scope.domElement.addEventListener('contextmenu', onContextMenu, false);

    scope.domElement.addEventListener('mousedown', onMouseDown, false);
    scope.domElement.addEventListener('wheel', onMouseWheel, false);

    scope.domElement.addEventListener('touchstart', onTouchStart, false);
    scope.domElement.addEventListener('touchend', onTouchEnd, false);
    scope.domElement.addEventListener('touchmove', onTouchMove, false);

    window.addEventListener('keydown', onKeyDown, false);

    // force an update at start

    this.update();
}

OrbitControls.prototype = Object.create(three.EventDispatcher.prototype);
OrbitControls.prototype.constructor = OrbitControls;

Object.defineProperties(OrbitControls.prototype, {

    center: {

        get: function get() {

            console.warn('THREE.OrbitControls: .center has been renamed to .target');
            return this.target;
        }

    },

    // backward compatibility

    noZoom: {

        get: function get() {

            console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
            return !this.enableZoom;
        },

        set: function set(value) {

            console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
            this.enableZoom = !value;
        }

    },

    noRotate: {

        get: function get() {

            console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
            return !this.enableRotate;
        },

        set: function set(value) {

            console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
            this.enableRotate = !value;
        }

    },

    noPan: {

        get: function get() {

            console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
            return !this.enablePan;
        },

        set: function set(value) {

            console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
            this.enablePan = !value;
        }

    },

    noKeys: {

        get: function get() {

            console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
            return !this.enableKeys;
        },

        set: function set(value) {

            console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
            this.enableKeys = !value;
        }

    },

    staticMoving: {

        get: function get() {

            console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
            return !this.enableDamping;
        },

        set: function set(value) {

            console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
            this.enableDamping = !value;
        }

    },

    dynamicDampingFactor: {

        get: function get() {

            console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
            return this.dampingFactor;
        },

        set: function set(value) {

            console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
            this.dampingFactor = value;
        }

    }

});

/**
 * @author aleeper / http://adamleeper.com/
 * @author mrdoob / http://mrdoob.com/
 * @author gero3 / https://github.com/gero3
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.
 *
 * Supports both binary and ASCII encoded files, with automatic detection of type.
 *
 * The loader returns a non-indexed buffer geometry.
 *
 * Limitations:
 *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
 *  There is perhaps some question as to how valid it is to always assume little-endian-ness.
 *  ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *  var loader = new THREE.STLLoader();
 *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {
 *    scene.add( new THREE.Mesh( geometry ) );
 *  });
 *
 * For binary STLs geometry might contain colors for vertices. To use it:
 *  // use the same code to load STL as above
 *  if (geometry.hasColors) {
 *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });
 *  } else { .... }
 *  var mesh = new THREE.Mesh( geometry, material );
 */

function STLLoader(manager) {

    this.manager = manager !== undefined ? manager : three.DefaultLoadingManager;
}

STLLoader.prototype = {

    constructor: STLLoader,

    load: function load(url, onLoad, onProgress, onError) {

        var scope = this;

        var loader = new three.FileLoader(scope.manager);
        loader.setResponseType('arraybuffer');
        loader.load(url, function (text) {

            onLoad(scope.parse(text));
        }, onProgress, onError);
    },

    parse: function parse(data) {

        var isBinary = function isBinary() {

            var expect, face_size, n_faces, reader;
            reader = new DataView(binData);
            face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
            n_faces = reader.getUint32(80, true);
            expect = 80 + 32 / 8 + n_faces * face_size;

            if (expect === reader.byteLength) {

                return true;
            }

            // An ASCII STL data must begin with 'solid ' as the first six bytes.
            // However, ASCII STLs lacking the SPACE after the 'd' are known to be
            // plentiful.  So, check the first 5 bytes for 'solid'.

            // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'
            var solid = [115, 111, 108, 105, 100];

            for (var i = 0; i < 5; i++) {

                // If solid[ i ] does not match the i-th byte, then it is not an
                // ASCII STL; hence, it is binary and return true.

                if (solid[i] != reader.getUint8(i, false)) return true;
            }

            // First 5 bytes read "solid"; declare it to be an ASCII STL
            return false;
        };

        var binData = this.ensureBinary(data);

        return isBinary() ? this.parseBinary(binData) : this.parseASCII(this.ensureString(data));
    },

    parseBinary: function parseBinary(data) {

        var reader = new DataView(data);
        var faces = reader.getUint32(80, true);

        var r,
            g,
            b,
            hasColors = false,
            colors;
        var defaultR, defaultG, defaultB, alpha;

        // process STL header
        // check for default color in header ("COLOR=rgba" sequence).

        for (var index = 0; index < 80 - 10; index++) {

            if (reader.getUint32(index, false) == 0x434F4C4F /*COLO*/ && reader.getUint8(index + 4) == 0x52 /*'R'*/ && reader.getUint8(index + 5) == 0x3D /*'='*/) {

                    hasColors = true;
                    colors = [];

                    defaultR = reader.getUint8(index + 6) / 255;
                    defaultG = reader.getUint8(index + 7) / 255;
                    defaultB = reader.getUint8(index + 8) / 255;
                    alpha = reader.getUint8(index + 9) / 255;
                }
        }

        var dataOffset = 84;
        var faceLength = 12 * 4 + 2;

        var geometry = new three.BufferGeometry();

        var vertices = [];
        var normals = [];

        for (var face = 0; face < faces; face++) {

            var start = dataOffset + face * faceLength;
            var normalX = reader.getFloat32(start, true);
            var normalY = reader.getFloat32(start + 4, true);
            var normalZ = reader.getFloat32(start + 8, true);

            if (hasColors) {

                var packedColor = reader.getUint16(start + 48, true);

                if ((packedColor & 0x8000) === 0) {

                    // facet has its own unique color

                    r = (packedColor & 0x1F) / 31;
                    g = (packedColor >> 5 & 0x1F) / 31;
                    b = (packedColor >> 10 & 0x1F) / 31;
                } else {

                    r = defaultR;
                    g = defaultG;
                    b = defaultB;
                }
            }

            for (var i = 1; i <= 3; i++) {

                var vertexstart = start + i * 12;

                vertices.push(reader.getFloat32(vertexstart, true));
                vertices.push(reader.getFloat32(vertexstart + 4, true));
                vertices.push(reader.getFloat32(vertexstart + 8, true));

                normals.push(normalX, normalY, normalZ);

                if (hasColors) {

                    colors.push(r, g, b);
                }
            }
        }

        geometry.addAttribute('position', new three.BufferAttribute(new Float32Array(vertices), 3));
        geometry.addAttribute('normal', new three.BufferAttribute(new Float32Array(normals), 3));

        if (hasColors) {

            geometry.addAttribute('color', new three.BufferAttribute(new Float32Array(colors), 3));
            geometry.hasColors = true;
            geometry.alpha = alpha;
        }

        return geometry;
    },

    parseASCII: function parseASCII(data) {

        var geometry, length, patternFace, patternNormal, patternVertex, result, text;
        geometry = new three.BufferGeometry();
        patternFace = /facet([\s\S]*?)endfacet/g;

        var vertices = [];
        var normals = [];

        var normal = new three.Vector3();

        while ((result = patternFace.exec(data)) !== null) {

            text = result[0];
            patternNormal = /normal[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;

            while ((result = patternNormal.exec(text)) !== null) {

                normal.x = parseFloat(result[1]);
                normal.y = parseFloat(result[3]);
                normal.z = parseFloat(result[5]);
            }

            patternVertex = /vertex[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;

            while ((result = patternVertex.exec(text)) !== null) {

                vertices.push(parseFloat(result[1]), parseFloat(result[3]), parseFloat(result[5]));
                normals.push(normal.x, normal.y, normal.z);
            }
        }

        geometry.addAttribute('position', new three.BufferAttribute(new Float32Array(vertices), 3));
        geometry.addAttribute('normal', new three.BufferAttribute(new Float32Array(normals), 3));

        return geometry;
    },

    ensureString: function ensureString(buf) {

        if (typeof buf !== "string") {

            var array_buffer = new Uint8Array(buf);
            var strArray = [];
            for (var i = 0; i < buf.byteLength; i++) {

                strArray.push(String.fromCharCode(array_buffer[i])); // implicitly assumes little-endian
            }
            return strArray.join('');
        } else {

            return buf;
        }
    },

    ensureBinary: function ensureBinary(buf) {

        if (typeof buf === "string") {

            var array_buffer = new Uint8Array(buf.length);
            for (var i = 0; i < buf.length; i++) {

                array_buffer[i] = buf.charCodeAt(i) & 0xff; // implicitly assumes little-endian
            }
            return array_buffer.buffer || array_buffer;
        } else {

            return buf;
        }
    }

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

var Detector = {

    canvas: !!window.CanvasRenderingContext2D,
    webgl: function () {

        try {

            var canvas = document.createElement('canvas');return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
        } catch (e) {

            return false;
        }
    }(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,

    getWebGLErrorMessage: function getWebGLErrorMessage() {

        var element = document.createElement('div');
        element.id = 'webgl-error-message';
        element.style.fontFamily = 'monospace';
        element.style.fontSize = '13px';
        element.style.fontWeight = 'normal';
        element.style.textAlign = 'center';
        element.style.background = '#fff';
        element.style.color = '#000';
        element.style.padding = '1.5em';
        element.style.width = '400px';
        element.style.margin = '5em auto 0';

        if (!this.webgl) {

            element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join('\n') : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'].join('\n');
        }

        return element;
    },

    addGetWebGLMessage: function addGetWebGLMessage(parameters) {

        var parent, id, element;

        parameters = parameters || {};

        parent = parameters.parent !== undefined ? parameters.parent : document.body;
        id = parameters.id !== undefined ? parameters.id : 'oldie';

        element = Detector.getWebGLErrorMessage();
        element.id = id;

        parent.appendChild(element);
    }

};

/**
 * @author kovacsv / http://kovacsv.hu/
 * @author mrdoob / http://mrdoob.com/
 * @author mudcube / http://mudcu.be/
 */

function STLBinaryExporter() {}

STLBinaryExporter.prototype = {

    constructor: STLBinaryExporter,

    parse: function () {

        var vector = new three.Vector3();
        var normalMatrixWorld = new three.Matrix3();

        return function parse(scene) {

            // We collect objects first, as we may need to convert from BufferGeometry to Geometry
            var objects = [];
            var triangles = 0;
            scene.traverse(function (object) {

                if (!(object instanceof three.Mesh)) return;

                var geometry = object.geometry;
                if (geometry instanceof three.BufferGeometry) {

                    geometry = new three.Geometry().fromBufferGeometry(geometry);
                }

                if (!(geometry instanceof three.Geometry)) return;
                triangles += geometry.faces.length;

                objects.push({

                    geometry: geometry,
                    matrix: object.matrixWorld

                });
            });

            var offset = 80; // skip header
            var bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;
            var arrayBuffer = new ArrayBuffer(bufferLength);
            var output = new DataView(arrayBuffer);
            output.setUint32(offset, triangles, true);offset += 4;

            // Traversing our collected objects
            objects.forEach(function (object) {

                var vertices = object.geometry.vertices;
                var faces = object.geometry.faces;

                normalMatrixWorld.getNormalMatrix(object.matrix);

                for (var i = 0, l = faces.length; i < l; i++) {

                    var face = faces[i];

                    vector.copy(face.normal).applyMatrix3(normalMatrixWorld).normalize();

                    output.setFloat32(offset, vector.x, true);offset += 4; // normal
                    output.setFloat32(offset, vector.y, true);offset += 4;
                    output.setFloat32(offset, vector.z, true);offset += 4;

                    var indices = [face.a, face.b, face.c];

                    for (var j = 0; j < 3; j++) {

                        vector.copy(vertices[indices[j]]).applyMatrix4(object.matrix);

                        output.setFloat32(offset, vector.x, true);offset += 4; // vertices
                        output.setFloat32(offset, vector.y, true);offset += 4;
                        output.setFloat32(offset, vector.z, true);offset += 4;
                    }

                    output.setUint16(offset, 0, true);offset += 2; // attribute byte count
                }
            });

            return output;
        };
    }()

};

/**
 * @author kennethjiang / https://github.com/kennethjiang
 *
 *
 * Description: A THREE view port for STL models
 *
 * Usage:
 *  var viewPort = new THREE.STLViewPort(canvas, width, height, function() {
 *     //things to do when any model in the view port changes
 *  });
 *  viewPort.init();
 *  viewPort.loadSTL(url, fucntion(model) {
 *     viewPort.makeModelActive(model);
 *     //things to do when model is loaded
 *  });
 *  var scene = viewPort.scene; // direct access to the scene for to add THREE.Object
 *
 */

function STLViewPort(canvas, width, height, onChange, onNewModel) {

    var self = this;

    self.canvas = canvas;
    self.canvasWidth = width;
    self.canvasHeight = height;
    self.onChange = onChange;
    self.onNewModel = onNewModel;

    self.models = [];

    self.effectController = {
        metalness: 0.5,
        roughness: 0.5,
        modelInactiveColor: new THREE.Color("#60715b"),
        modelActiveColor: new THREE.Color("#34bf0d"),
        ambientLightColor: new THREE.Color("#2b2b2b"),
        directionalLightColor: new THREE.Color("#ffffff")
    };

    self.init = function () {

        self.camera = new THREE.PerspectiveCamera(45, 1.0, 0.1, 5000);

        self.camera.up.set(0, 0, 1);
        self.camera.position.set(-100, -200, 250);

        self.scene = new THREE.Scene();

        // Lights
        var ambientLight = new THREE.AmbientLight(self.effectController.ambientLightColor); // 0.2
        self.scene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(self.effectController.directionalLightColor, 1.0);
        directionalLight.position.set(100, 100, 500);
        self.scene.add(directionalLight);
        var directionalLight2 = new THREE.DirectionalLight(self.effectController.directionalLightColor, 1.0);
        directionalLight2.position.set(100, 100, -500);
        self.scene.add(directionalLight2);

        self.renderer = new THREE.WebGLRenderer({ canvas: self.canvas, antialias: true });

        self.renderer.setClearColor(0xd8d8d8);
        self.renderer.setSize(self.canvasWidth, self.canvasHeight);
        self.renderer.setPixelRatio(window.devicePixelRatio);

        self.renderer.gammaInput = true;
        self.renderer.gammaOutput = true;

        self.orbitControls = new OrbitControls(self.camera, self.renderer.domElement);

        self.orbitControls.enableDamping = true;
        self.orbitControls.dampingFactor = 0.25;
        self.orbitControls.enablePan = false;
        self.orbitControls.addEventListener("change", self.render);

        self.transformControls = new TransformControls(self.camera, self.renderer.domElement);

        self.transformControls.setRotationSnap(THREE.Math.degToRad(15));
        self.transformControls.addEventListener("change", self.render);
        self.transformControls.addEventListener("mouseDown", self.startTransform);
        self.transformControls.addEventListener("mouseUp", self.endTransform);
        self.transformControls.addEventListener("change", self.onChange);
        self.scene.add(self.transformControls);

        window.addEventListener('keydown', function (event) {
            switch (event.keyCode) {
                case 17:
                    // Ctrl
                    self.transformControls.setRotationSnap(null);
                    break;
            }
        });

        window.addEventListener('keyup', function (event) {
            switch (event.keyCode) {
                case 17:
                    // Ctrl
                    self.transformControls.setRotationSnap(THREE.Math.degToRad(15));
                    break;
            }
        });

        // Unforutnately built-in "click" event is fired when it's a drag. We need all these complexity to detect real click (no mousemoves between mousedown and mouseup)
        self.canvas.addEventListener("mousedown", function () {
            self.lastMouseEvent = "mousedown";
        });
        self.canvas.addEventListener("mousemove", function () {
            self.lastMouseEvent = "mousemove";
        });
        self.canvas.addEventListener("mouseup", function (e) {
            if (self.lastMouseEvent == "mousedown") self.pickActiveModel(e);
        });

        self.render();
    };

    self.render = function () {
        self.renderer.render(self.scene, self.camera);
    };

    self.refresh = function () {
        self.transformControls.update();
        self.orbitControls.update();
        self.render();
    };

    self.loadSTL = function (url, onLoad) {
        new STLLoader().load(url, function (geometry) {
            self.onNewModel([self.addModelOfGeometry(geometry)]);
        });
    };

    self.addModelOfGeometry = function (geometry, modelToCopyTransformFrom) {
        var material = new THREE.MeshStandardMaterial({
            color: self.effectController.modelInactiveColor, // We'll mark it active below.
            shading: THREE.SmoothShading,
            side: THREE.DoubleSide,
            metalness: self.effectController.metalness,
            roughness: self.effectController.roughness });

        var stlModel = new THREE.Mesh(geometry, material);

        // center model's origin
        var center = new THREE.Box3().setFromObject(stlModel).center();
        var model = new THREE.Object3D();
        model.add(stlModel);
        stlModel.position.copy(center.negate());
        if (modelToCopyTransformFrom) {
            model.rotation.copy(modelToCopyTransformFrom.rotation);
            model.scale.copy(modelToCopyTransformFrom.scale);
        }

        self.scene.add(model);
        self.render();

        self.models.push(model);
        return model;
    };

    self.activeModel = function () {
        return self.transformControls.object;
    };

    self.pickActiveModel = function (event) {
        var rect = self.canvas.getBoundingClientRect();
        var x = (event.clientX - rect.left) / rect.width;
        var y = (event.clientY - rect.top) / rect.height;

        var pointerVector = new THREE.Vector2();
        pointerVector.set(x * 2 - 1, -(y * 2) + 1);
        var ray = new THREE.Raycaster();
        ray.setFromCamera(pointerVector, self.camera);

        // Clicking should cycle through the stlFiles if there are multiple under the cursor.
        var foundActiveModel = false;
        var nextPointedModel = undefined;
        var firstPointedModel = undefined;
        for (var i = 0; i < self.models.length; i++) {
            var model = self.models[i];
            var intersections = ray.intersectObjects(model.children, true); // Not sure why ray will intersect the children but not the model itself.
            if (!intersections[0]) {
                continue;
            }
            if (!firstPointedModel) {
                firstPointedModel = model;
            }
            if (foundActiveModel && !nextPointedModel) {
                nextPointedModel = model;
            }
            if (self.activeModel() == model) {
                foundActiveModel = true;
            }
        }
        if (nextPointedModel) {
            self.makeModelActive(nextPointedModel);
        } else if (firstPointedModel) {
            self.makeModelActive(firstPointedModel);
        }
    };

    /**
     * params:
     *    m: model to make active. Clear active model if m is undefined
     *
     */
    self.makeModelActive = function (m) {
        // Sets one file active and inactivates all the others.
        if (m) {
            self.transformControls.attach(m);
        } else {
            self.transformControls.detach();
        }

        for (var i = 0; i < self.models.length; i++) {
            var model = self.models[i];
            if (model == self.activeModel()) {
                model.children[0].material.color.copy(self.effectController.modelActiveColor);
            } else {
                model.children[0].material.color.copy(self.effectController.modelInactiveColor);
            }
        }

        self.render();
        self.onChange();
    };

    self.removeActiveModel = function () {
        if (!self.activeModel()) {
            return undefined;
        } else {
            var model = self.activeModel();

            var index = self.models.indexOf(model);
            if (index > -1) {
                self.models.splice(index, 1);
            }

            self.scene.remove(model);
            self.makeModelActive(undefined);
            return model;
        }
    };

    self.removeAllModels = function () {
        for (var i = 0; i < self.models.length; i++) {
            self.scene.remove(self.models[i]);
        }
        self.models = [];
        self.makeModelActive(undefined);
    };

    self.splitActiveModel = function () {
        if (!self.activeModel()) {
            return;
        } else {
            var originalModel = self.removeActiveModel();
            var geometry = originalModel.children[0].geometry;
            var newGeometries = GeometryUtils.split(geometry);
            self.onNewModel(newGeometries.map(function (geometry) {
                return self.addModelOfGeometry(geometry, originalModel);
            }));
        }
    };

    self.onlyOneOriginalModel = function () {
        return self.models.length == 1 && self.models[0].position.x == 0.0 && self.models[0].position.y == 0.0 && self.models[0].rotation.x == 0.0 && self.models[0].rotation.y == 0.0 && self.models[0].rotation.z == 0.0 && self.models[0].scale.x == 1.0 && self.models[0].scale.y == 1.0 && self.models[0].scale.z == 1.0;
    };

    self.startTransform = function () {
        // Disable orbit controls
        self.orbitControls.enabled = false;
    };

    self.endTransform = function () {
        // Enable orbit controls
        self.orbitControls.enabled = true;
    };
}

/*
 * View model for OctoPrint-Slicer
 *
 * Author: Kenneth Jiang
 * License: AGPLv3
 */
ko.bindingHandlers.numericValue = {
    init: function init(element, valueAccessor, allBindings, data, context) {
        var interceptor = ko.computed({
            read: function read() {
                return ko.unwrap(valueAccessor());
            },
            write: function write(value) {
                if (!isNaN(value)) {
                    valueAccessor()(parseFloat(value));
                }
            },
            disposeWhenNodeIsRemoved: element
        });

        ko.applyBindingsToNode(element, { value: interceptor }, context);
    }
};

function OverridesViewModel(parameters, array_keys, enum_keys, item_keys, boolean_keys) {
    var self = this;
    self.slicingViewModel = parameters[0];

    var ARRAY_KEYS = ["print_temperature", "start_gcode", "end_gcode", "filament_diameter"],
        ENUM_KEYS = {
        "support": ko.observableArray(["none", "buildplate", "everywhere"]),
        "platform_adhesion": ko.observableArray(["none", "brim", "raft"])
    },
        ITEM_KEYS = ["layer_height", "temperature", "bed_temperature", "print_bed_temperature", "fill_density", "wall_thickness", "print_speed", "solid_layer_thickness", "travel_speed", "outer_shell_speed", "inner_shell_speed", "infill_speed", "bottom_layer_speed", "filament_flow", "retraction_speed", "retraction_amount", "extrusion_multiplier"],
        BOOLEAN_KEYS = ["support_material", "overhangs", "retraction_enable", "fan_enabled", "cooling"];
    var ALL_KEYS = BOOLEAN_KEYS.concat(ITEM_KEYS).concat(ARRAY_KEYS).concat(Object.keys(ENUM_KEYS));

    // initialize all observables
    _.forEach(ALL_KEYS, function (k) {
        self["profile." + k] = ko.observable();
    });

    self.optionsForKey = function (key) {
        return ENUM_KEYS[key];
    };

    self.updateOverridesFromProfile = function (profile) {

        // Some options are numeric but might have a percent sign after them.
        // Remove the percent and save it to replace later.
        self.endings = {};
        var stripEndings = function stripEndings(m, k) {
            if (_.isString(m[k]) && m[k].endsWith("%")) {
                self.endings[k] = "%";
                return m[k].slice(0, -1);
            } else {
                return m[k];
            }
        };

        // Some options are booleans but can be stored as 0/1 or false/true.
        // Convert to native true/false and keep track of the style.
        self.booleans = {};
        var convertBoolean = function convertBoolean(m, k) {
            var BOOLS = [["false", "true"], ["False", "True"], ["0", "1"]];
            if (m[k] === undefined) {
                return undefined;
            }
            for (var boolType = 0; boolType < BOOLS.length; boolType++) {
                for (var b = 0; b < BOOLS[boolType].length; b++) {
                    if (m[k] === BOOLS[boolType][b]) {
                        self.booleans[k] = BOOLS[boolType];
                        return !!b; // Convert 0 to false and 1 to true.
                    }
                }
            }
            return !!m[k]; // Just take a guess if we can't figure it out.
        };

        // Some options are arrays in cura but not Slic3r.  Keep track of which.
        self.isArray = [];

        _.forEach(ITEM_KEYS, function (k) {
            self["profile." + k](stripEndings(profile, k));
        });
        _.forEach(BOOLEAN_KEYS, function (k) {
            self["profile." + k](convertBoolean(profile, k));
        });
        _.forEach(ENUM_KEYS, function (v, k) {
            self["profile." + k](profile[k]);
        });
        _.forEach(ARRAY_KEYS, function (k) {
            // Some config options are arrays in cura but not in Slic3r.
            // Detect which ones are arrays and only convert those.
            if (_.isArray(profile[k])) {
                self.isArray.push(k); // Remember this for later.
                self["profile." + k](profile[k][0]);
            } else {
                self["profile." + k](profile[k]);
            }
        });
    };

    self.onProfileChange = function (newValue) {
        if (newValue === undefined) {
            // For some reason KO would fire event with newValue=undefined,
            return; // in which case we should ignore it otherwise things get messed up
        }

        var slicing = self.slicingViewModel;

        if (!slicing.slicer() || !slicing.profile()) {
            return;
        }

        self.fetchSlicingProfile(slicing.slicer(), slicing.profile());
    };

    self.fetchSlicingProfile = function (slicer, profile) {
        if (self.profileAjax) {
            self.profileAjax.abort();
            self.profileAjax = undefined;
        }

        self.profileAjax = $.ajax({
            url: API_BASEURL + "slicing/" + slicer + "/profiles/" + profile,
            type: "GET",
            // On success
            success: function success(data) {
                self.updateOverridesFromProfile(data.data);
            }
        });
    };

    self.slicingViewModel.profile.subscribe(self.onProfileChange);
    //
    //End of Profile-handling mess


    self.toJS = function () {
        var result = ko.mapping.toJS(self, {
            ignore: ["slicingViewModel", "updateOverridesFromProfile", "updateOverrides", "toJS", "optionsForKey", "stripEndings", "isArray", "endings"]
        });
        _.forEach(ITEM_KEYS, function (k) {
            if (self.endings.hasOwnProperty(k)) {
                result["profile." + k] += self.endings[k];
            }
        });
        _.forEach(BOOLEAN_KEYS, function (k) {
            if (self.booleans.hasOwnProperty(k)) {
                // Convert false/true to the correct string.
                result["profile." + k] = self.booleans[k][result["profile." + k] ? 1 : 0];
            }
        });

        for (var key in result) {
            var baseKey = key.replace("profile.", "");
            // Convert it back to an array if it was an array originally.
            if (_.contains(ARRAY_KEYS, baseKey) && _.contains(self.isArray, baseKey)) {
                result[key] = [result[key]];
            }
        }

        _.forEach(result, function (k) {
            // If the value is undefined, must not be valid for this slicer.
            if (result[k] === undefined) {
                delete result[k];
            }
        });
        return result;
    };
}

// view model class, parameters for constructor, container to bind to
OCTOPRINT_VIEWMODELS.push([OverridesViewModel, ["slicingViewModel"], ["#basic_overrides", "#advanced_overrides"]]);

function ModelArranger() {

    var self = this;

    var sort = {

        w: function w(a, b) {
            return b.w - a.w;
        },
        h: function h(a, b) {
            return b.h - a.h;
        },
        a: function a(_a, b) {
            return b.area - _a.area;
        },
        max: function max(a, b) {
            return Math.max(b.w, b.h) - Math.max(a.w, a.h);
        },
        min: function min(a, b) {
            return Math.min(b.w, b.h) - Math.min(a.w, a.h);
        },

        height: function height(a, b) {
            return sort.msort(a, b, ['h', 'w']);
        },
        width: function width(a, b) {
            return sort.msort(a, b, ['w', 'h']);
        },
        area: function area(a, b) {
            return sort.msort(a, b, ['a', 'h', 'w']);
        },
        maxside: function maxside(a, b) {
            return sort.msort(a, b, ['max', 'min', 'h', 'w']);
        },

        msort: function msort(a, b, criteria) {
            /* sort by multiple criteria */
            var diff, n;
            for (n = 0; n < criteria.length; n++) {
                diff = sort[criteria[n]](a, b);
                if (diff != 0) return diff;
            }
            return 0;
        }

    };

    function applyPackResult(rect, packer) {
        rect.model.position.x = rect.fit.x - packer.root.w * 0.5 + rect.w * 0.5;
        rect.model.position.y = rect.fit.y - packer.root.h * 0.5 + rect.h * 0.5;
    }

    function projectedRectOnXY(model) {
        var margin = 10.0;
        var modelBox = new three.Box3().setFromObject(model);
        var width = modelBox.max.x - modelBox.min.x + margin;
        var height = modelBox.max.y - modelBox.min.y + margin;
        return { w: width, h: height, area: width * height, model: model };
    }

    self.arrange = function (models) {
        var modelRectMap = models.reduce(function (map, model) {
            return map.set(model, projectedRectOnXY(model));
        }, new Map());

        // loop through all sorting criteria, and pick the best one (with smalles overall area)
        var criteria = ['w', 'h', 'a', 'max', 'min', 'height', 'width', 'area', 'maxside'];
        var allPackers = criteria.map(function (crit) {

            var rects = models.map(function (model) {
                return modelRectMap.get(model);
            });
            rects.sort(sort[crit]);

            var packer = new GrowingPacker();
            packer.fit(rects);

            return { packer: packer, rects: rects };
        });

        var packersSortedByArea = allPackers.filter(function (result) {
            return !result.rects.some(function (rect) {
                return !rect.fit;
            });
        }).sort(function (a, b) {
            return b.packer.root.area - a.packer.root.area;
        });

        if (packersSortedByArea.length > 0) {
            packersSortedByArea[0].rects.forEach(function (rect) {
                applyPackResult(rect, packersSortedByArea[0].packer);
            });
        }
    };
}

/*
 * View model for OctoPrint-Slicer
 *
 * Author: Kenneth Jiang
 * License: AGPLv3
 */

if (window.location.hostname != "localhost") {
    Raven.config('https://85bd9314656d40da9249aec5a32a2b52@sentry.io/141297', {
        release: '1.0.3',
        ignoreErrors: ["Failed to execute 'arc' on 'CanvasRenderingContext2D': The radius provided", "Cannot read property 'highlightFill' of undefined", "Argument 1 of SVGMatrix.translate is not a finite floating-point value", /_jp.*is not a function/, "chrome is not defined"]
    }).install();
}

function SlicerViewModel(parameters) {
    mixpanel.track("App Loaded");

    var self = this;

    self.canvas = document.getElementById('slicer-canvas');

    //check if webGL is present. If not disable Slicer plugin
    if (!Detector.webgl) {
        $('#tab_plugin_slicer').empty().append("<h3>Slicer Plugin is disabled because your browser doesn't support WebGL</h3>");
        return;
    }

    // assign the injected parameters, e.g.:
    self.slicingViewModel = parameters[0];
    self.overridesViewModel = parameters[1];
    self.printerStateViewModel = parameters[2];
    self.printerProfilesViewModel = parameters[3];

    self.lockScale = true;
    self.selectedSTL = undefined;
    self.newPrint = true;

    // Override slicingViewModel.show to surpress default slicing behavior
    self.slicingViewModel.show = function (target, file, force) {
        if (!self.slicingViewModel.enableSlicingDialog() && !force) {
            return;
        }
        mixpanel.track("Load STL");

        $('a[href="#tab_plugin_slicer"]').tab('show');

        self.selectedSTL = { target: target, file: file };
        if (self.newPrint) {
            self.addToNewPrint();
        } else {
            $("#plugin-slicer-load-model").modal("show");
        }
    };

    self.addToNewPrint = function () {
        self.clearPrint();
        self.addToExistingPrint();
    };

    self.addToExistingPrint = function () {
        self.setSlicingViewModel(self.selectedSTL.target, self.selectedSTL.file);
        self.addSTL(self.selectedSTL.target, self.selectedSTL.file);
        self.selectedSTL = undefined;

        $("#plugin-slicer-load-model").modal("hide");
    };

    self.clearPrint = function () {
        self.resetSlicingViewModel();
        self.stlViewPort.removeAllModels();
        self.newPrint = true;
    };

    self.addSTL = function (target, file) {
        self.newPrint = false;
        self.stlViewPort.loadSTL(BASEURL + "downloads/files/" + target + "/" + file);
    };

    self.onModelAdd = function (models) {

        self.stlViewPort.makeModelActive(models[0]);

        models.forEach(function (model) {
            self.fixZPosition(model);
        });

        if (self.stlViewPort.models.length > 1) {
            new ModelArranger().arrange(self.stlViewPort.models);
        }
        self.stlViewPort.refresh();

        $('#tab_plugin_slicer > div.translucent-blocker').hide();
    };

    self.onModelRemove = function (model) {
        if (self.stlViewPort.models.length == 0) {
            self.clearPrint();
        }
    };

    self.updatePrinterBed = function (profileName) {
        if (profileName) {
            var profile = self.printerProfilesViewModel.profiles.items().find(function (p) {
                return p.id == profileName;
            });

            var dim = profile.volume;
            self.BEDSIZE_X_MM = dim.width;
            self.BEDSIZE_Y_MM = dim.depth;
            self.BEDSIZE_Z_MM = dim.height;
            if (dim.origin == "lowerleft") {
                self.ORIGIN_OFFSET_X_MM = self.BEDSIZE_X_MM / 2.0;
                self.ORIGIN_OFFSET_Y_MM = self.BEDSIZE_Y_MM / 2.0;
            } else {
                self.ORIGIN_OFFSET_X_MM = 0;
                self.ORIGIN_OFFSET_Y_MM = 0;
            }
        }
        self.drawBedFloor(self.BEDSIZE_X_MM, self.BEDSIZE_Y_MM);
        self.drawWalls(self.BEDSIZE_X_MM, self.BEDSIZE_Y_MM, self.BEDSIZE_Z_MM);
        self.stlViewPort.refresh();
    };

    self.slicingViewModel.printerProfile.subscribe(self.updatePrinterBed);

    self.BEDSIZE_X_MM = 200;
    self.BEDSIZE_Y_MM = 200;
    self.BEDSIZE_Z_MM = 200;
    self.ORIGIN_OFFSET_X_MM = 0;
    self.ORIGIN_OFFSET_Y_MM = 0;

    var CANVAS_WIDTH = 588,
        CANVAS_HEIGHT = 588;

    self.init = function () {

        self.slicingViewModel.requestData();

        self.stlViewPort = new STLViewPort(self.canvas, CANVAS_WIDTH, CANVAS_HEIGHT, self.onModelChange, self.onModelAdd);
        self.stlViewPort.init();

        //Walls and Floor
        self.walls = new THREE.Object3D();
        self.floor = new THREE.Object3D();
        self.stlViewPort.scene.add(self.walls);
        self.stlViewPort.scene.add(self.floor);

        self.updatePrinterBed();

        ko.applyBindings(self.slicingViewModel, $('#slicing-settings')[0]);

        // Buttons on the canvas, and their behaviors.
        // TODO: it's not DRY. mix of prez code and logics. need to figure out a better way
        $("#slicer-viewport").empty().append('<div class="report"><span>Got issues or suggestions? <a target="_blank" href="https://github.com/kennethjiang/OctoPrint-Slicer/issues/new">Click here!</a></span></div>\
                  <div class="model">\
                    <button class="translate disabled" title="Move"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/translate.png"></button>\
                    <button class="rotate disabled" title="Rotate"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/rotate.png"></button>\
                    <button class="scale disabled" title="Scale"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/scale.png"></button>\
                    <button class="remove disabled" title="Remove"><img src="' + PLUGIN_BASEURL + 'slicer/static/img/remove.png"></button>\
                </div>\
                <div class="values translate">\
                    <div>\
                        <p><span class="axis x">X</span><input type="number" step="any" name="x"><span title="">mm</span></p>\
                        <p><span class="axis y">Y</span><input type="number" step="any" name="y"><span title="">mm</span></p>\
                        <span></span>\
                    </div>\
               </div>\
                <div class="values rotate">\
                    <div>\
                        <p><span class="axis x">X</span><input type="number" step="any" name="x"><span title="">°</span></p>\
                        <p><span class="axis y">Y</span><input type="number" step="any" name="y"><span title="">°</span></p>\
                        <p><span class="axis z">Z</span><input type="number" step="any" name="z"><span title="">°</span></p>\
                        <span></span>\
                    </div>\
               </div>\
                <div class="values scale">\
                    <div>\
                        <p><span class="axis x">X</span><input type="number" step="0.001" name="x" min="0.001"></p>\
                        <p><span class="axis y">Y</span><input type="number" step="0.001" name="y" min="0.001"></p>\
                        <p><span class="axis z">Z</span><input type="number" step="0.001" name="z" min="0.001"></p>\
                        <p class="checkbox"><label><input type="checkbox" checked>Lock</label></p>\
                        <span></span>\
                    </div>\
               </div>');

        $("#slicer-viewport").append(self.stlViewPort.renderer.domElement);

        $("#slicer-viewport button.translate").click(function (event) {
            self.stlViewPort.transformControls.setMode("translate");
            self.stlViewPort.transformControls.space = "world";
            self.toggleValueInputs($("#slicer-viewport .translate.values div"));
        });
        $("#slicer-viewport button.rotate").click(function (event) {
            self.stlViewPort.transformControls.setMode("rotate");
            self.stlViewPort.transformControls.space = "world";
            self.toggleValueInputs($("#slicer-viewport .rotate.values div"));
        });
        $("#slicer-viewport button.scale").click(function (event) {
            self.stlViewPort.transformControls.setMode("scale");
            self.stlViewPort.transformControls.space = "local";
            self.toggleValueInputs($("#slicer-viewport .scale.values div"));
        });
        $("#slicer-viewport button.remove").click(function (event) {
            self.onModelRemove(self.stlViewPort.removeActiveModel());
        });
        $("#slicer-viewport button.split").click(function (event) {
            self.onModelRemove(self.stlViewPort.splitActiveModel());
        });
        $("#slicer-viewport .values input").change(function () {
            self.applyValueInputs($(this));
        });
    };

    self.toggleValueInputs = function (parentDiv) {
        if (parentDiv.hasClass("show")) {
            parentDiv.removeClass("show").children('p').removeClass("show");
        } else if (self.stlViewPort.activeModel()) {
            $("#slicer-viewport .values div").removeClass("show");
            parentDiv.addClass("show").children('p').addClass("show");
        }
    };

    self.applyValueInputs = function (input) {
        input.blur();
        if (input[0].type == "checkbox") {
            self.lockScale = input[0].checked;
        } else if (input[0].type == "number" && !isNaN(parseFloat(input.val()))) {
            input.val(parseFloat(input.val()).toFixed(3));
            var model = self.stlViewPort.activeModel();

            if (input.closest(".values").hasClass("scale") && self.lockScale) {
                $("#slicer-viewport .scale.values input").val(input.val());
                console.log($("#slicer-viewport .scale.values input[name=\"x\"]").val());
            }

            model.position.x = parseFloat($("#slicer-viewport .translate.values input[name=\"x\"]").val());
            model.position.y = parseFloat($("#slicer-viewport .translate.values input[name=\"y\"]").val());
            model.rotation.x = THREE.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"x\"]").val());
            model.rotation.y = THREE.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"y\"]").val());
            model.rotation.z = THREE.Math.degToRad($("#slicer-viewport .rotate.values input[name=\"z\"]").val());
            model.scale.x = parseFloat($("#slicer-viewport .scale.values input[name=\"x\"]").val());
            model.scale.y = parseFloat($("#slicer-viewport .scale.values input[name=\"y\"]").val());
            model.scale.z = parseFloat($("#slicer-viewport .scale.values input[name=\"z\"]").val());
            self.fixZPosition(model);
            self.stlViewPort.refresh();
        }
    };

    self.fixZPosition = function (model) {
        var bedLowMinZ = 0.0;
        var boundaryBox = new THREE.Box3().setFromObject(model);
        boundaryBox.min.sub(model.position);
        boundaryBox.max.sub(model.position);
        model.position.z -= model.position.z + boundaryBox.min.z - bedLowMinZ;
    };

    // callback function when models are changed by TransformControls
    self.onModelChange = function () {
        var model = self.stlViewPort.activeModel();
        if (model) {
            $("#slicer-viewport .translate.values input[name=\"x\"]").val(model.position.x.toFixed(3)).attr("min", '');
            $("#slicer-viewport .translate.values input[name=\"y\"]").val(model.position.y.toFixed(3)).attr("min", '');
            $("#slicer-viewport .rotate.values input[name=\"x\"]").val((model.rotation.x * 180 / Math.PI).toFixed(3)).attr("min", '');
            $("#slicer-viewport .rotate.values input[name=\"y\"]").val((model.rotation.y * 180 / Math.PI).toFixed(3)).attr("min", '');
            $("#slicer-viewport .rotate.values input[name=\"z\"]").val((model.rotation.z * 180 / Math.PI).toFixed(3)).attr("min", '');
            $("#slicer-viewport .scale.values input[name=\"x\"]").val(model.scale.x.toFixed(3)).attr("min", '');
            $("#slicer-viewport .scale.values input[name=\"y\"]").val(model.scale.y.toFixed(3)).attr("min", '');
            $("#slicer-viewport .scale.values input[name=\"z\"]").val(model.scale.z.toFixed(3)).attr("min", '');
            $("#slicer-viewport .scale.values input[type=\"checkbox\"]").checked = self.lockScale;
            self.fixZPosition(model);
            self.stlViewPort.refresh();
        }

        if (!self.stlViewPort.activeModel()) {
            $("#slicer-viewport .values div").removeClass("show");
            $("#slicer-viewport button").addClass("disabled");
        } else {
            $("#slicer-viewport button").removeClass("disabled");
        }
    };

    // Slicing
    //
    self.tempFiles = {};
    self.removeTempFilesAfterSlicing = function (event) {
        if ($.inArray(event.data.type, ["SlicingDone", "SlicingFailed"]) >= 0 && event.data.payload.stl in self.tempFiles) {
            OctoPrint.files.delete(event.data.payload.stl_location, event.data.payload.stl);
            delete self.tempFiles[event.data.payload.stl];
        }
    };

    OctoPrint.socket.onMessage("event", self.removeTempFilesAfterSlicing);

    self.sliceRequestData = function (slicingVM, group) {
        var destinationFilename = slicingVM._sanitize(slicingVM.destinationFilename());

        var destinationExtensions = slicingVM.data[slicingVM.slicer()] && slicingVM.data[slicingVM.slicer()].extensions && slicingVM.data[slicingVM.slicer()].extensions.destination ? slicingVM.data[slicingVM.slicer()].extensions.destination : ["???"];
        if (!_.any(destinationExtensions, function (extension) {
            return _.endsWith(destinationFilename.toLowerCase(), "." + extension.toLowerCase());
        })) {
            destinationFilename = destinationFilename + "." + destinationExtensions[0];
        }
        var groupCenter = new THREE.Vector3(0, 0, 0);
        if (group) {
            groupCenter = new THREE.Box3().setFromObject(group).center();
        }
        var data = {
            command: "slice",
            slicer: slicingVM.slicer(),
            profile: slicingVM.profile(),
            printerProfile: slicingVM.printerProfile(),
            destination: destinationFilename,
            position: { "x": self.ORIGIN_OFFSET_X_MM + groupCenter.x,
                "y": self.ORIGIN_OFFSET_Y_MM + groupCenter.y }
        };
        _.extend(data, self.overridesViewModel.toJS());

        if (slicingVM.afterSlicing() == "print") {
            data["print"] = true;
        } else if (slicingVM.afterSlicing() == "select") {
            data["select"] = true;
        }
        return data;
    };

    self.sendSliceRequest = function (target, filename, data) {
        $.ajax({
            url: API_BASEURL + "files/" + target + "/" + filename,
            type: "POST",
            dataType: "json",
            contentType: "application/json; charset=UTF-8",
            data: JSON.stringify(data),
            error: function error(jqXHR, textStatus) {
                new PNotify({ title: "Slicing failed", text: textStatus, type: "error", hide: false });
            }
        });
    };

    self.slice = function () {
        mixpanel.track("Slice Model");

        var target = self.slicingViewModel.target;
        var sliceRequestData;

        if (self.stlViewPort.onlyOneOriginalModel()) {

            sliceRequestData = self.sliceRequestData(self.slicingViewModel);
            self.sendSliceRequest(self.slicingViewModel.target, self.slicingViewModel.file(), sliceRequestData);
        } else {

            var form = new FormData();
            var group = new THREE.Group();
            _.forEach(self.stlViewPort.models, function (model) {
                group.add(model.clone(true));
            });

            sliceRequestData = self.sliceRequestData(self.slicingViewModel, group);

            var tempFilename = self.tempSTLFilename();
            form.append("file", self.blobFromModel(group), tempFilename);
            $.ajax({
                url: API_BASEURL + "files/local",
                type: "POST",
                data: form,
                processData: false,
                contentType: false,
                // On success
                success: function success(_) {
                    self.tempFiles[tempFilename] = 1;
                    self.sendSliceRequest(target, tempFilename, sliceRequestData);
                },
                error: function error(jqXHR, textStatus) {
                    new PNotify({ title: "Slicing failed", text: textStatus, type: "error", hide: false });
                }
            });
        }
    };

    self.blobFromModel = function (model) {
        var exporter = new STLBinaryExporter();
        return new Blob([exporter.parse(model)], { type: "text/plain" });
    };

    self.isPrinting = ko.computed(function () {
        return self.printerStateViewModel.isPrinting() || self.printerStateViewModel.isPaused();
    });

    self.canSliceNow = ko.computed(function () {
        // TODO: We should be checking for same_device here, too.
        return self.slicingViewModel.enableSliceButton() && !self.isPrinting();
    });
    // END: Slicing

    // Helpers for drawing walls and floor
    //
    self.createText = function (font, text, width, depth, parentObj) {
        var textGeometry = new THREE.TextGeometry(text, {
            font: font,
            size: 10,
            height: 0.1,
            material: 0, extrudeMaterial: 1
        });
        var materialFront = new THREE.MeshBasicMaterial({ color: 0x048e06 });
        var materialSide = new THREE.MeshBasicMaterial({ color: 0x8A8A8A });
        var materialArray = [materialFront, materialSide];
        var textMaterial = new THREE.MeshFaceMaterial(materialArray);

        var mesh = new THREE.Mesh(textGeometry, textMaterial);
        textGeometry.computeBoundingBox();
        var textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
        var textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;
        switch (text) {
            case "Front":
                mesh.position.set(-textWidth / 2, -depth / 2 - textHeight - 4, 1.0);
                break;
            case "Back":
                mesh.position.set(textWidth / 2, depth / 2 + textHeight + 4, 1.0);
                mesh.rotation.set(0, 0, Math.PI);
                break;
            case "Left":
                mesh.position.set(-width / 2 - textHeight - 4, textWidth / 2, 1.0);
                mesh.rotation.set(0, 0, -Math.PI / 2);
                break;
            case "Right":
                mesh.position.set(width / 2 + textHeight, -textWidth / 2, 1.0);
                mesh.rotation.set(0, 0, Math.PI / 2);
                break;
        }
        parentObj.add(mesh);
    };

    self.drawBedFloor = function (width, depth, segments) {
        for (var i = self.floor.children.length - 1; i >= 0; i--) {
            var obj = self.floor.children[i];
            self.floor.remove(obj);
        }

        segments = segments || 20;
        var geometry = new THREE.PlaneGeometry(width, depth, segments, segments);
        var materialEven = new THREE.MeshBasicMaterial({ color: 0xccccfc });
        var materialOdd = new THREE.MeshBasicMaterial({ color: 0x444464 });
        var materials = [materialEven, materialOdd];
        for (var x = 0; x < segments; x++) {
            for (var y = 0; y < segments; y++) {
                var i = x * segments + y;
                var j = 2 * i;
                geometry.faces[j].materialIndex = geometry.faces[j + 1].materialIndex = (x + y) % 2;
            }
        }
        var mesh = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));
        mesh.receiveShadow = true;
        self.floor.add(mesh);

        //Add text to indicate front/back of print bed
        var loader = new THREE.FontLoader();
        loader.load(PLUGIN_BASEURL + "slicer/static/js/optimer_bold.typeface.json", function (font) {
            self.createText(font, "Front", width, depth, self.floor);
            self.createText(font, "Back", width, depth, self.floor);
            self.createText(font, "Left", width, depth, self.floor);
            self.createText(font, "Right", width, depth, self.floor);
            self.stlViewPort.refresh();
        });
    };

    self.drawWalls = function (width, depth, height) {
        for (var i = self.walls.children.length - 1; i >= 0; i--) {
            var obj = self.walls.children[i];
            self.walls.remove(obj);
        }

        var wall1 = self.rectShape(width, height, 0x8888fc);
        wall1.rotation.x = Math.PI / 2;
        wall1.position.set(0, depth / 2, height / 2);
        self.walls.add(wall1);

        var wall2 = self.rectShape(height, depth, 0x8888dc);
        wall2.rotation.y = Math.PI / 2;
        wall2.position.set(-width / 2, 0, height / 2);
        self.walls.add(wall2);

        var wall3 = self.rectShape(width, height, 0x8888fc);
        wall3.rotation.x = -Math.PI / 2;
        wall3.position.set(0, -depth / 2, height / 2);
        self.walls.add(wall3);

        var wall4 = self.rectShape(height, depth, 0x8888dc);
        wall4.rotation.y = -Math.PI / 2;
        wall4.position.set(width / 2, 0, height / 2);
        self.walls.add(wall4);
    };

    self.rectShape = function (rectLength, rectWidth, color) {
        var rectShape = new THREE.Shape();
        rectShape.moveTo(-rectLength / 2, -rectWidth / 2);
        rectShape.lineTo(-rectLength / 2, rectWidth / 2);
        rectShape.lineTo(rectLength / 2, rectWidth / 2);
        rectShape.lineTo(rectLength / 2, -rectWidth / 2);
        rectShape.lineTo(-rectLength / 2, -rectWidth / 2);
        var rectGeom = new THREE.ShapeGeometry(rectShape);
        return new THREE.Mesh(rectGeom, new THREE.MeshBasicMaterial({ color: color }));
    };
    // END: Helpers for drawing walls and floor

    self.resetSlicingViewModel = function () {
        self.slicingViewModel.target = undefined;
        self.slicingViewModel.file(undefined);
        self.slicingViewModel.destinationFilename(undefined);
    };

    self.setSlicingViewModel = function (target, filename) {
        if (!self.slicingViewModel.destinationFilename()) {
            // A model is added to an empty bed
            self.slicingViewModel.target = target;
            self.slicingViewModel.file(filename);
            self.slicingViewModel.destinationFilename(self.computeDestinationFilename(filename));
        }
    };

    // Returns the destination filename based on which models are loaded.
    // The destination filename is without the final .gco on it because
    // that will depend on the slicer.
    self.computeDestinationFilename = function (inputFilename) {
        // TODO: For now, just use the first model's name.
        var destinationFilename = inputFilename.substr(0, inputFilename.lastIndexOf("."));
        if (destinationFilename.lastIndexOf("/") != 0) {
            destinationFilename = destinationFilename.substr(destinationFilename.lastIndexOf("/") + 1);
        }
        return destinationFilename;
    };

    self.tempSTLFilename = function () {
        var pos = self.slicingViewModel.file().lastIndexOf(".");
        return [self.slicingViewModel.file().slice(0, pos), ".tmp." + +new Date(), self.slicingViewModel.file().slice(pos)].join('');
    };

    self.init();
}

// view model class, parameters for constructor, container to bind to
OCTOPRINT_VIEWMODELS.push([SlicerViewModel,

// e.g. loginStateViewModel, settingsViewModel, ...
["slicingViewModel", "overridesViewModel", "printerStateViewModel", "printerProfilesViewModel"],

// e.g. #settings_plugin_slicer, #tab_plugin_slicer, ...
["#slicer"]]);

}(THREE));
